// pkg/ffmpegd/proto/ffmpegd.proto
//
// tvarr-ffmpegd Protocol Buffer Service Definition
// This file defines the gRPC service for daemon-coordinator communication.
//
// Third-party clients can use this file to generate client code in any language.
// Install protoc and run:
//   protoc --go_out=. --go-grpc_out=. pkg/ffmpegd/proto/ffmpegd.proto

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: pkg/ffmpegd/proto/ffmpegd.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GPUClass categorizes GPU types for session limit detection
type GPUClass int32

const (
	GPUClass_GPU_CLASS_UNKNOWN      GPUClass = 0
	GPUClass_GPU_CLASS_CONSUMER     GPUClass = 1 // GeForce, Radeon - limited encode sessions
	GPUClass_GPU_CLASS_PROFESSIONAL GPUClass = 2 // Quadro, Pro - high/unlimited limits
	GPUClass_GPU_CLASS_DATACENTER   GPUClass = 3 // Tesla, A100 - no artificial limits
	GPUClass_GPU_CLASS_INTEGRATED   GPUClass = 4 // Intel iGPU, AMD APU - shared memory
)

// Enum value maps for GPUClass.
var (
	GPUClass_name = map[int32]string{
		0: "GPU_CLASS_UNKNOWN",
		1: "GPU_CLASS_CONSUMER",
		2: "GPU_CLASS_PROFESSIONAL",
		3: "GPU_CLASS_DATACENTER",
		4: "GPU_CLASS_INTEGRATED",
	}
	GPUClass_value = map[string]int32{
		"GPU_CLASS_UNKNOWN":      0,
		"GPU_CLASS_CONSUMER":     1,
		"GPU_CLASS_PROFESSIONAL": 2,
		"GPU_CLASS_DATACENTER":   3,
		"GPU_CLASS_INTEGRATED":   4,
	}
)

func (x GPUClass) Enum() *GPUClass {
	p := new(GPUClass)
	*p = x
	return p
}

func (x GPUClass) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GPUClass) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[0].Descriptor()
}

func (GPUClass) Type() protoreflect.EnumType {
	return &file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[0]
}

func (x GPUClass) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GPUClass.Descriptor instead.
func (GPUClass) EnumDescriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{0}
}

type DaemonCommand_CommandType int32

const (
	DaemonCommand_COMMAND_UNSPECIFIED DaemonCommand_CommandType = 0
	DaemonCommand_DRAIN               DaemonCommand_CommandType = 1 // Stop accepting new jobs
	DaemonCommand_RESUME              DaemonCommand_CommandType = 2 // Resume accepting jobs
	DaemonCommand_CANCEL_JOB          DaemonCommand_CommandType = 3 // Cancel specific job
	DaemonCommand_UPDATE_CONFIG       DaemonCommand_CommandType = 4 // Update configuration
	DaemonCommand_START_JOB           DaemonCommand_CommandType = 5 // Start a transcode job (daemon initiates stream to coordinator)
)

// Enum value maps for DaemonCommand_CommandType.
var (
	DaemonCommand_CommandType_name = map[int32]string{
		0: "COMMAND_UNSPECIFIED",
		1: "DRAIN",
		2: "RESUME",
		3: "CANCEL_JOB",
		4: "UPDATE_CONFIG",
		5: "START_JOB",
	}
	DaemonCommand_CommandType_value = map[string]int32{
		"COMMAND_UNSPECIFIED": 0,
		"DRAIN":               1,
		"RESUME":              2,
		"CANCEL_JOB":          3,
		"UPDATE_CONFIG":       4,
		"START_JOB":           5,
	}
)

func (x DaemonCommand_CommandType) Enum() *DaemonCommand_CommandType {
	p := new(DaemonCommand_CommandType)
	*p = x
	return p
}

func (x DaemonCommand_CommandType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DaemonCommand_CommandType) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[1].Descriptor()
}

func (DaemonCommand_CommandType) Type() protoreflect.EnumType {
	return &file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[1]
}

func (x DaemonCommand_CommandType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DaemonCommand_CommandType.Descriptor instead.
func (DaemonCommand_CommandType) EnumDescriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{6, 0}
}

type TranscodeError_ErrorCode int32

const (
	TranscodeError_ERROR_UNSPECIFIED     TranscodeError_ErrorCode = 0
	TranscodeError_FFMPEG_START_FAILED   TranscodeError_ErrorCode = 1
	TranscodeError_FFMPEG_CRASHED        TranscodeError_ErrorCode = 2
	TranscodeError_CODEC_UNSUPPORTED     TranscodeError_ErrorCode = 3
	TranscodeError_HW_ACCEL_FAILED       TranscodeError_ErrorCode = 4
	TranscodeError_SESSION_LIMIT_REACHED TranscodeError_ErrorCode = 5
	TranscodeError_OUT_OF_MEMORY         TranscodeError_ErrorCode = 6
	TranscodeError_TIMEOUT               TranscodeError_ErrorCode = 7
)

// Enum value maps for TranscodeError_ErrorCode.
var (
	TranscodeError_ErrorCode_name = map[int32]string{
		0: "ERROR_UNSPECIFIED",
		1: "FFMPEG_START_FAILED",
		2: "FFMPEG_CRASHED",
		3: "CODEC_UNSUPPORTED",
		4: "HW_ACCEL_FAILED",
		5: "SESSION_LIMIT_REACHED",
		6: "OUT_OF_MEMORY",
		7: "TIMEOUT",
	}
	TranscodeError_ErrorCode_value = map[string]int32{
		"ERROR_UNSPECIFIED":     0,
		"FFMPEG_START_FAILED":   1,
		"FFMPEG_CRASHED":        2,
		"CODEC_UNSUPPORTED":     3,
		"HW_ACCEL_FAILED":       4,
		"SESSION_LIMIT_REACHED": 5,
		"OUT_OF_MEMORY":         6,
		"TIMEOUT":               7,
	}
)

func (x TranscodeError_ErrorCode) Enum() *TranscodeError_ErrorCode {
	p := new(TranscodeError_ErrorCode)
	*p = x
	return p
}

func (x TranscodeError_ErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TranscodeError_ErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[2].Descriptor()
}

func (TranscodeError_ErrorCode) Type() protoreflect.EnumType {
	return &file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes[2]
}

func (x TranscodeError_ErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TranscodeError_ErrorCode.Descriptor instead.
func (TranscodeError_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{24, 0}
}

type RegisterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique daemon identifier (UUID or ULID)
	DaemonId string `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	// Human-readable name for dashboard display
	DaemonName string `protobuf:"bytes,2,opt,name=daemon_name,json=daemonName,proto3" json:"daemon_name,omitempty"`
	// tvarr-ffmpegd version (semver)
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Daemon's capabilities (encoders, decoders, hardware acceleration)
	Capabilities *Capabilities `protobuf:"bytes,4,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Authentication token (must match coordinator's TVARR_FFMPEGD_AUTH_TOKEN)
	AuthToken     string `protobuf:"bytes,5,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() {
	*x = RegisterRequest{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterRequest) ProtoMessage() {}

func (x *RegisterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{0}
}

func (x *RegisterRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *RegisterRequest) GetDaemonName() string {
	if x != nil {
		return x.DaemonName
	}
	return ""
}

func (x *RegisterRequest) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *RegisterRequest) GetCapabilities() *Capabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *RegisterRequest) GetAuthToken() string {
	if x != nil {
		return x.AuthToken
	}
	return ""
}

type RegisterResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether registration succeeded
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Error message if registration failed
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Coordinator's expected heartbeat interval
	HeartbeatInterval *durationpb.Duration `protobuf:"bytes,3,opt,name=heartbeat_interval,json=heartbeatInterval,proto3" json:"heartbeat_interval,omitempty"`
	// Coordinator version for compatibility checking
	CoordinatorVersion string `protobuf:"bytes,4,opt,name=coordinator_version,json=coordinatorVersion,proto3" json:"coordinator_version,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() {
	*x = RegisterResponse{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterResponse) ProtoMessage() {}

func (x *RegisterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{1}
}

func (x *RegisterResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RegisterResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RegisterResponse) GetHeartbeatInterval() *durationpb.Duration {
	if x != nil {
		return x.HeartbeatInterval
	}
	return nil
}

func (x *RegisterResponse) GetCoordinatorVersion() string {
	if x != nil {
		return x.CoordinatorVersion
	}
	return ""
}

type UnregisterRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DaemonId      string                 `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"` // "shutdown", "maintenance", etc.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnregisterRequest) Reset() {
	*x = UnregisterRequest{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnregisterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnregisterRequest) ProtoMessage() {}

func (x *UnregisterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnregisterRequest.ProtoReflect.Descriptor instead.
func (*UnregisterRequest) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{2}
}

func (x *UnregisterRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *UnregisterRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type UnregisterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnregisterResponse) Reset() {
	*x = UnregisterResponse{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnregisterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnregisterResponse) ProtoMessage() {}

func (x *UnregisterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnregisterResponse.ProtoReflect.Descriptor instead.
func (*UnregisterResponse) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{3}
}

func (x *UnregisterResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type HeartbeatRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	DaemonId string                 `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	// Current system statistics
	SystemStats *SystemStats `protobuf:"bytes,2,opt,name=system_stats,json=systemStats,proto3" json:"system_stats,omitempty"`
	// Currently active transcoding jobs
	ActiveJobs    []*JobStatus `protobuf:"bytes,3,rep,name=active_jobs,json=activeJobs,proto3" json:"active_jobs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatRequest) Reset() {
	*x = HeartbeatRequest{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatRequest) ProtoMessage() {}

func (x *HeartbeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatRequest.ProtoReflect.Descriptor instead.
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{4}
}

func (x *HeartbeatRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *HeartbeatRequest) GetSystemStats() *SystemStats {
	if x != nil {
		return x.SystemStats
	}
	return nil
}

func (x *HeartbeatRequest) GetActiveJobs() []*JobStatus {
	if x != nil {
		return x.ActiveJobs
	}
	return nil
}

type HeartbeatResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Commands from coordinator (optional)
	Commands      []*DaemonCommand `protobuf:"bytes,2,rep,name=commands,proto3" json:"commands,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatResponse) Reset() {
	*x = HeartbeatResponse{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatResponse) ProtoMessage() {}

func (x *HeartbeatResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatResponse.ProtoReflect.Descriptor instead.
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{5}
}

func (x *HeartbeatResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *HeartbeatResponse) GetCommands() []*DaemonCommand {
	if x != nil {
		return x.Commands
	}
	return nil
}

// DaemonCommand allows coordinator to send instructions to daemon
type DaemonCommand struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Type          DaemonCommand_CommandType `protobuf:"varint,1,opt,name=type,proto3,enum=ffmpegd.DaemonCommand_CommandType" json:"type,omitempty"`
	JobId         string                    `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"` // For CANCEL_JOB and START_JOB
	Payload       []byte                    `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`          // For UPDATE_CONFIG (JSON) or START_JOB (TranscodeJobConfig JSON)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DaemonCommand) Reset() {
	*x = DaemonCommand{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DaemonCommand) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DaemonCommand) ProtoMessage() {}

func (x *DaemonCommand) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DaemonCommand.ProtoReflect.Descriptor instead.
func (*DaemonCommand) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{6}
}

func (x *DaemonCommand) GetType() DaemonCommand_CommandType {
	if x != nil {
		return x.Type
	}
	return DaemonCommand_COMMAND_UNSPECIFIED
}

func (x *DaemonCommand) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *DaemonCommand) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// TranscodeJobConfig is sent as JSON payload in START_JOB command.
// The daemon uses this to know which job to start and connect back to coordinator.
type TranscodeJobConfig struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	JobId       string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	SessionId   string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ChannelId   string                 `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	ChannelName string                 `protobuf:"bytes,4,opt,name=channel_name,json=channelName,proto3" json:"channel_name,omitempty"`
	// Target codec (daemon picks best encoder based on its capabilities)
	TargetVideoCodec string `protobuf:"bytes,5,opt,name=target_video_codec,json=targetVideoCodec,proto3" json:"target_video_codec,omitempty"` // vp9, h264, hevc, av1
	TargetAudioCodec string `protobuf:"bytes,6,opt,name=target_audio_codec,json=targetAudioCodec,proto3" json:"target_audio_codec,omitempty"` // opus, aac, ac3
	// Encoding parameters
	VideoBitrateKbps int32  `protobuf:"varint,7,opt,name=video_bitrate_kbps,json=videoBitrateKbps,proto3" json:"video_bitrate_kbps,omitempty"`
	AudioBitrateKbps int32  `protobuf:"varint,8,opt,name=audio_bitrate_kbps,json=audioBitrateKbps,proto3" json:"audio_bitrate_kbps,omitempty"`
	VideoPreset      string `protobuf:"bytes,9,opt,name=video_preset,json=videoPreset,proto3" json:"video_preset,omitempty"` // ultrafast, fast, medium, slow
	// Hardware acceleration preference (empty = auto)
	PreferredHwAccel string `protobuf:"bytes,10,opt,name=preferred_hw_accel,json=preferredHwAccel,proto3" json:"preferred_hw_accel,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TranscodeJobConfig) Reset() {
	*x = TranscodeJobConfig{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeJobConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeJobConfig) ProtoMessage() {}

func (x *TranscodeJobConfig) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeJobConfig.ProtoReflect.Descriptor instead.
func (*TranscodeJobConfig) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{7}
}

func (x *TranscodeJobConfig) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *TranscodeJobConfig) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *TranscodeJobConfig) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

func (x *TranscodeJobConfig) GetChannelName() string {
	if x != nil {
		return x.ChannelName
	}
	return ""
}

func (x *TranscodeJobConfig) GetTargetVideoCodec() string {
	if x != nil {
		return x.TargetVideoCodec
	}
	return ""
}

func (x *TranscodeJobConfig) GetTargetAudioCodec() string {
	if x != nil {
		return x.TargetAudioCodec
	}
	return ""
}

func (x *TranscodeJobConfig) GetVideoBitrateKbps() int32 {
	if x != nil {
		return x.VideoBitrateKbps
	}
	return 0
}

func (x *TranscodeJobConfig) GetAudioBitrateKbps() int32 {
	if x != nil {
		return x.AudioBitrateKbps
	}
	return 0
}

func (x *TranscodeJobConfig) GetVideoPreset() string {
	if x != nil {
		return x.VideoPreset
	}
	return ""
}

func (x *TranscodeJobConfig) GetPreferredHwAccel() string {
	if x != nil {
		return x.PreferredHwAccel
	}
	return ""
}

type JobStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	JobId         string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ChannelName   string                 `protobuf:"bytes,3,opt,name=channel_name,json=channelName,proto3" json:"channel_name,omitempty"`
	Stats         *TranscodeStats        `protobuf:"bytes,4,opt,name=stats,proto3" json:"stats,omitempty"`
	RunningTime   *durationpb.Duration   `protobuf:"bytes,5,opt,name=running_time,json=runningTime,proto3" json:"running_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JobStatus) Reset() {
	*x = JobStatus{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JobStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JobStatus) ProtoMessage() {}

func (x *JobStatus) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JobStatus.ProtoReflect.Descriptor instead.
func (*JobStatus) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{8}
}

func (x *JobStatus) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *JobStatus) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *JobStatus) GetChannelName() string {
	if x != nil {
		return x.ChannelName
	}
	return ""
}

func (x *JobStatus) GetStats() *TranscodeStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *JobStatus) GetRunningTime() *durationpb.Duration {
	if x != nil {
		return x.RunningTime
	}
	return nil
}

type Capabilities struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Available hardware accelerators
	HwAccels []*HWAccelInfo `protobuf:"bytes,1,rep,name=hw_accels,json=hwAccels,proto3" json:"hw_accels,omitempty"`
	// GPU information with session limits
	Gpus []*GPUInfo `protobuf:"bytes,2,rep,name=gpus,proto3" json:"gpus,omitempty"`
	// Supported video encoders (e.g., libx264, h264_nvenc, hevc_vaapi)
	VideoEncoders []string `protobuf:"bytes,3,rep,name=video_encoders,json=videoEncoders,proto3" json:"video_encoders,omitempty"`
	// Supported video decoders (e.g., h264, hevc, h264_cuvid)
	VideoDecoders []string `protobuf:"bytes,4,rep,name=video_decoders,json=videoDecoders,proto3" json:"video_decoders,omitempty"`
	// Supported audio encoders (e.g., aac, libopus, ac3)
	AudioEncoders []string `protobuf:"bytes,5,rep,name=audio_encoders,json=audioEncoders,proto3" json:"audio_encoders,omitempty"`
	// Supported audio decoders (e.g., aac, ac3, eac3, mp3)
	AudioDecoders []string `protobuf:"bytes,6,rep,name=audio_decoders,json=audioDecoders,proto3" json:"audio_decoders,omitempty"`
	// Maximum concurrent transcoding jobs this daemon will accept
	MaxConcurrentJobs int32 `protobuf:"varint,7,opt,name=max_concurrent_jobs,json=maxConcurrentJobs,proto3" json:"max_concurrent_jobs,omitempty"`
	// Optional performance benchmark results
	Performance   *PerformanceMetrics `protobuf:"bytes,8,opt,name=performance,proto3" json:"performance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Capabilities) Reset() {
	*x = Capabilities{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Capabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Capabilities) ProtoMessage() {}

func (x *Capabilities) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Capabilities.ProtoReflect.Descriptor instead.
func (*Capabilities) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{9}
}

func (x *Capabilities) GetHwAccels() []*HWAccelInfo {
	if x != nil {
		return x.HwAccels
	}
	return nil
}

func (x *Capabilities) GetGpus() []*GPUInfo {
	if x != nil {
		return x.Gpus
	}
	return nil
}

func (x *Capabilities) GetVideoEncoders() []string {
	if x != nil {
		return x.VideoEncoders
	}
	return nil
}

func (x *Capabilities) GetVideoDecoders() []string {
	if x != nil {
		return x.VideoDecoders
	}
	return nil
}

func (x *Capabilities) GetAudioEncoders() []string {
	if x != nil {
		return x.AudioEncoders
	}
	return nil
}

func (x *Capabilities) GetAudioDecoders() []string {
	if x != nil {
		return x.AudioDecoders
	}
	return nil
}

func (x *Capabilities) GetMaxConcurrentJobs() int32 {
	if x != nil {
		return x.MaxConcurrentJobs
	}
	return 0
}

func (x *Capabilities) GetPerformance() *PerformanceMetrics {
	if x != nil {
		return x.Performance
	}
	return nil
}

// HWAccelInfo describes a hardware acceleration method.
// Maps directly to internal/ffmpeg.HWAccelInfo for consistency.
type HWAccelInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Acceleration type: vaapi, cuda, qsv, videotoolbox, d3d11va, dxva2
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Device path or name: /dev/dri/renderD128, GPU 0, etc.
	Device string `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	// Whether this accelerator is available and tested
	Available bool `protobuf:"varint,3,opt,name=available,proto3" json:"available,omitempty"`
	// Hardware encoders available and validated for this accelerator
	HwEncoders []string `protobuf:"bytes,4,rep,name=hw_encoders,json=hwEncoders,proto3" json:"hw_encoders,omitempty"`
	// Hardware decoders available for this accelerator
	HwDecoders []string `protobuf:"bytes,5,rep,name=hw_decoders,json=hwDecoders,proto3" json:"hw_decoders,omitempty"`
	// Hardware encoders that were filtered out (e.g., GPU doesn't support encoding)
	FilteredEncoders []*FilteredEncoder `protobuf:"bytes,6,rep,name=filtered_encoders,json=filteredEncoders,proto3" json:"filtered_encoders,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *HWAccelInfo) Reset() {
	*x = HWAccelInfo{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HWAccelInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HWAccelInfo) ProtoMessage() {}

func (x *HWAccelInfo) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HWAccelInfo.ProtoReflect.Descriptor instead.
func (*HWAccelInfo) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{10}
}

func (x *HWAccelInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *HWAccelInfo) GetDevice() string {
	if x != nil {
		return x.Device
	}
	return ""
}

func (x *HWAccelInfo) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

func (x *HWAccelInfo) GetHwEncoders() []string {
	if x != nil {
		return x.HwEncoders
	}
	return nil
}

func (x *HWAccelInfo) GetHwDecoders() []string {
	if x != nil {
		return x.HwDecoders
	}
	return nil
}

func (x *HWAccelInfo) GetFilteredEncoders() []*FilteredEncoder {
	if x != nil {
		return x.FilteredEncoders
	}
	return nil
}

// FilteredEncoder describes an encoder that was filtered out and why.
// Used by the UI to show which encoders are unavailable with explanations.
type FilteredEncoder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Encoder name (e.g., "vp9_vaapi", "hevc_vaapi")
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Reason the encoder was filtered out
	Reason        string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FilteredEncoder) Reset() {
	*x = FilteredEncoder{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FilteredEncoder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilteredEncoder) ProtoMessage() {}

func (x *FilteredEncoder) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilteredEncoder.ProtoReflect.Descriptor instead.
func (*FilteredEncoder) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{11}
}

func (x *FilteredEncoder) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *FilteredEncoder) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// GPUInfo describes a GPU and its session tracking
type GPUInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// GPU index (0-based)
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// GPU name (e.g., "NVIDIA GeForce RTX 3080")
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// GPU class for session limit detection
	GpuClass GPUClass `protobuf:"varint,3,opt,name=gpu_class,json=gpuClass,proto3,enum=ffmpegd.GPUClass" json:"gpu_class,omitempty"`
	// Driver version
	DriverVersion string `protobuf:"bytes,4,opt,name=driver_version,json=driverVersion,proto3" json:"driver_version,omitempty"`
	// Session limits (critical for load balancing)
	MaxEncodeSessions    int32 `protobuf:"varint,5,opt,name=max_encode_sessions,json=maxEncodeSessions,proto3" json:"max_encode_sessions,omitempty"`
	MaxDecodeSessions    int32 `protobuf:"varint,6,opt,name=max_decode_sessions,json=maxDecodeSessions,proto3" json:"max_decode_sessions,omitempty"`
	ActiveEncodeSessions int32 `protobuf:"varint,7,opt,name=active_encode_sessions,json=activeEncodeSessions,proto3" json:"active_encode_sessions,omitempty"`
	ActiveDecodeSessions int32 `protobuf:"varint,8,opt,name=active_decode_sessions,json=activeDecodeSessions,proto3" json:"active_decode_sessions,omitempty"`
	// Current utilization metrics
	UtilizationPercent float64 `protobuf:"fixed64,9,opt,name=utilization_percent,json=utilizationPercent,proto3" json:"utilization_percent,omitempty"` // 0-100
	MemoryTotalBytes   uint64  `protobuf:"varint,10,opt,name=memory_total_bytes,json=memoryTotalBytes,proto3" json:"memory_total_bytes,omitempty"`
	MemoryUsedBytes    uint64  `protobuf:"varint,11,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	EncoderUtilization float64 `protobuf:"fixed64,12,opt,name=encoder_utilization,json=encoderUtilization,proto3" json:"encoder_utilization,omitempty"` // NVENC utilization %
	DecoderUtilization float64 `protobuf:"fixed64,13,opt,name=decoder_utilization,json=decoderUtilization,proto3" json:"decoder_utilization,omitempty"` // NVDEC utilization %
	TemperatureCelsius int32   `protobuf:"varint,14,opt,name=temperature_celsius,json=temperatureCelsius,proto3" json:"temperature_celsius,omitempty"`
	PowerWatts         int32   `protobuf:"varint,15,opt,name=power_watts,json=powerWatts,proto3" json:"power_watts,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GPUInfo) Reset() {
	*x = GPUInfo{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GPUInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GPUInfo) ProtoMessage() {}

func (x *GPUInfo) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GPUInfo.ProtoReflect.Descriptor instead.
func (*GPUInfo) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{12}
}

func (x *GPUInfo) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *GPUInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GPUInfo) GetGpuClass() GPUClass {
	if x != nil {
		return x.GpuClass
	}
	return GPUClass_GPU_CLASS_UNKNOWN
}

func (x *GPUInfo) GetDriverVersion() string {
	if x != nil {
		return x.DriverVersion
	}
	return ""
}

func (x *GPUInfo) GetMaxEncodeSessions() int32 {
	if x != nil {
		return x.MaxEncodeSessions
	}
	return 0
}

func (x *GPUInfo) GetMaxDecodeSessions() int32 {
	if x != nil {
		return x.MaxDecodeSessions
	}
	return 0
}

func (x *GPUInfo) GetActiveEncodeSessions() int32 {
	if x != nil {
		return x.ActiveEncodeSessions
	}
	return 0
}

func (x *GPUInfo) GetActiveDecodeSessions() int32 {
	if x != nil {
		return x.ActiveDecodeSessions
	}
	return 0
}

func (x *GPUInfo) GetUtilizationPercent() float64 {
	if x != nil {
		return x.UtilizationPercent
	}
	return 0
}

func (x *GPUInfo) GetMemoryTotalBytes() uint64 {
	if x != nil {
		return x.MemoryTotalBytes
	}
	return 0
}

func (x *GPUInfo) GetMemoryUsedBytes() uint64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *GPUInfo) GetEncoderUtilization() float64 {
	if x != nil {
		return x.EncoderUtilization
	}
	return 0
}

func (x *GPUInfo) GetDecoderUtilization() float64 {
	if x != nil {
		return x.DecoderUtilization
	}
	return 0
}

func (x *GPUInfo) GetTemperatureCelsius() int32 {
	if x != nil {
		return x.TemperatureCelsius
	}
	return 0
}

func (x *GPUInfo) GetPowerWatts() int32 {
	if x != nil {
		return x.PowerWatts
	}
	return 0
}

type PerformanceMetrics struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	H264_1080PFps float64                `protobuf:"fixed64,1,opt,name=h264_1080p_fps,json=h2641080pFps,proto3" json:"h264_1080p_fps,omitempty"` // Benchmark: H.264 1080p encode speed
	H265_1080PFps float64                `protobuf:"fixed64,2,opt,name=h265_1080p_fps,json=h2651080pFps,proto3" json:"h265_1080p_fps,omitempty"` // Benchmark: H.265 1080p encode speed
	MemoryGb      float64                `protobuf:"fixed64,3,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty"`               // Available memory
	CpuCores      int32                  `protobuf:"varint,4,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores,omitempty"`                // CPU core count
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PerformanceMetrics) Reset() {
	*x = PerformanceMetrics{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerformanceMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerformanceMetrics) ProtoMessage() {}

func (x *PerformanceMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerformanceMetrics.ProtoReflect.Descriptor instead.
func (*PerformanceMetrics) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{13}
}

func (x *PerformanceMetrics) GetH264_1080PFps() float64 {
	if x != nil {
		return x.H264_1080PFps
	}
	return 0
}

func (x *PerformanceMetrics) GetH265_1080PFps() float64 {
	if x != nil {
		return x.H265_1080PFps
	}
	return 0
}

func (x *PerformanceMetrics) GetMemoryGb() float64 {
	if x != nil {
		return x.MemoryGb
	}
	return 0
}

func (x *PerformanceMetrics) GetCpuCores() int32 {
	if x != nil {
		return x.CpuCores
	}
	return 0
}

type SystemStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Host identification
	Hostname      string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Os            string `protobuf:"bytes,2,opt,name=os,proto3" json:"os,omitempty"`     // linux, darwin, windows
	Arch          string `protobuf:"bytes,3,opt,name=arch,proto3" json:"arch,omitempty"` // amd64, arm64
	UptimeSeconds int64  `protobuf:"varint,4,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	// CPU metrics
	CpuCores    int32     `protobuf:"varint,5,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores,omitempty"`
	CpuPercent  float64   `protobuf:"fixed64,6,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"` // Overall CPU usage (0-100)
	CpuPerCore  []float64 `protobuf:"fixed64,7,rep,packed,name=cpu_per_core,json=cpuPerCore,proto3" json:"cpu_per_core,omitempty"`
	LoadAvg_1M  float64   `protobuf:"fixed64,8,opt,name=load_avg_1m,json=loadAvg1m,proto3" json:"load_avg_1m,omitempty"`
	LoadAvg_5M  float64   `protobuf:"fixed64,9,opt,name=load_avg_5m,json=loadAvg5m,proto3" json:"load_avg_5m,omitempty"`
	LoadAvg_15M float64   `protobuf:"fixed64,10,opt,name=load_avg_15m,json=loadAvg15m,proto3" json:"load_avg_15m,omitempty"`
	// Memory metrics
	MemoryTotalBytes     uint64  `protobuf:"varint,11,opt,name=memory_total_bytes,json=memoryTotalBytes,proto3" json:"memory_total_bytes,omitempty"`
	MemoryUsedBytes      uint64  `protobuf:"varint,12,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	MemoryAvailableBytes uint64  `protobuf:"varint,13,opt,name=memory_available_bytes,json=memoryAvailableBytes,proto3" json:"memory_available_bytes,omitempty"`
	MemoryPercent        float64 `protobuf:"fixed64,14,opt,name=memory_percent,json=memoryPercent,proto3" json:"memory_percent,omitempty"`
	SwapTotalBytes       uint64  `protobuf:"varint,15,opt,name=swap_total_bytes,json=swapTotalBytes,proto3" json:"swap_total_bytes,omitempty"`
	SwapUsedBytes        uint64  `protobuf:"varint,16,opt,name=swap_used_bytes,json=swapUsedBytes,proto3" json:"swap_used_bytes,omitempty"`
	// Disk metrics (work directory)
	DiskTotalBytes     uint64  `protobuf:"varint,17,opt,name=disk_total_bytes,json=diskTotalBytes,proto3" json:"disk_total_bytes,omitempty"`
	DiskUsedBytes      uint64  `protobuf:"varint,18,opt,name=disk_used_bytes,json=diskUsedBytes,proto3" json:"disk_used_bytes,omitempty"`
	DiskAvailableBytes uint64  `protobuf:"varint,19,opt,name=disk_available_bytes,json=diskAvailableBytes,proto3" json:"disk_available_bytes,omitempty"`
	DiskPercent        float64 `protobuf:"fixed64,20,opt,name=disk_percent,json=diskPercent,proto3" json:"disk_percent,omitempty"`
	// Network metrics
	NetworkBytesSent   uint64  `protobuf:"varint,21,opt,name=network_bytes_sent,json=networkBytesSent,proto3" json:"network_bytes_sent,omitempty"`
	NetworkBytesRecv   uint64  `protobuf:"varint,22,opt,name=network_bytes_recv,json=networkBytesRecv,proto3" json:"network_bytes_recv,omitempty"`
	NetworkSendRateBps float64 `protobuf:"fixed64,23,opt,name=network_send_rate_bps,json=networkSendRateBps,proto3" json:"network_send_rate_bps,omitempty"`
	NetworkRecvRateBps float64 `protobuf:"fixed64,24,opt,name=network_recv_rate_bps,json=networkRecvRateBps,proto3" json:"network_recv_rate_bps,omitempty"`
	// GPU metrics (per GPU)
	Gpus []*GPUStats `protobuf:"bytes,25,rep,name=gpus,proto3" json:"gpus,omitempty"`
	// Linux PSI pressure indicators
	CpuPressure    *PressureStats `protobuf:"bytes,26,opt,name=cpu_pressure,json=cpuPressure,proto3" json:"cpu_pressure,omitempty"`
	MemoryPressure *PressureStats `protobuf:"bytes,27,opt,name=memory_pressure,json=memoryPressure,proto3" json:"memory_pressure,omitempty"`
	IoPressure     *PressureStats `protobuf:"bytes,28,opt,name=io_pressure,json=ioPressure,proto3" json:"io_pressure,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SystemStats) Reset() {
	*x = SystemStats{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SystemStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SystemStats) ProtoMessage() {}

func (x *SystemStats) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SystemStats.ProtoReflect.Descriptor instead.
func (*SystemStats) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{14}
}

func (x *SystemStats) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *SystemStats) GetOs() string {
	if x != nil {
		return x.Os
	}
	return ""
}

func (x *SystemStats) GetArch() string {
	if x != nil {
		return x.Arch
	}
	return ""
}

func (x *SystemStats) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

func (x *SystemStats) GetCpuCores() int32 {
	if x != nil {
		return x.CpuCores
	}
	return 0
}

func (x *SystemStats) GetCpuPercent() float64 {
	if x != nil {
		return x.CpuPercent
	}
	return 0
}

func (x *SystemStats) GetCpuPerCore() []float64 {
	if x != nil {
		return x.CpuPerCore
	}
	return nil
}

func (x *SystemStats) GetLoadAvg_1M() float64 {
	if x != nil {
		return x.LoadAvg_1M
	}
	return 0
}

func (x *SystemStats) GetLoadAvg_5M() float64 {
	if x != nil {
		return x.LoadAvg_5M
	}
	return 0
}

func (x *SystemStats) GetLoadAvg_15M() float64 {
	if x != nil {
		return x.LoadAvg_15M
	}
	return 0
}

func (x *SystemStats) GetMemoryTotalBytes() uint64 {
	if x != nil {
		return x.MemoryTotalBytes
	}
	return 0
}

func (x *SystemStats) GetMemoryUsedBytes() uint64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *SystemStats) GetMemoryAvailableBytes() uint64 {
	if x != nil {
		return x.MemoryAvailableBytes
	}
	return 0
}

func (x *SystemStats) GetMemoryPercent() float64 {
	if x != nil {
		return x.MemoryPercent
	}
	return 0
}

func (x *SystemStats) GetSwapTotalBytes() uint64 {
	if x != nil {
		return x.SwapTotalBytes
	}
	return 0
}

func (x *SystemStats) GetSwapUsedBytes() uint64 {
	if x != nil {
		return x.SwapUsedBytes
	}
	return 0
}

func (x *SystemStats) GetDiskTotalBytes() uint64 {
	if x != nil {
		return x.DiskTotalBytes
	}
	return 0
}

func (x *SystemStats) GetDiskUsedBytes() uint64 {
	if x != nil {
		return x.DiskUsedBytes
	}
	return 0
}

func (x *SystemStats) GetDiskAvailableBytes() uint64 {
	if x != nil {
		return x.DiskAvailableBytes
	}
	return 0
}

func (x *SystemStats) GetDiskPercent() float64 {
	if x != nil {
		return x.DiskPercent
	}
	return 0
}

func (x *SystemStats) GetNetworkBytesSent() uint64 {
	if x != nil {
		return x.NetworkBytesSent
	}
	return 0
}

func (x *SystemStats) GetNetworkBytesRecv() uint64 {
	if x != nil {
		return x.NetworkBytesRecv
	}
	return 0
}

func (x *SystemStats) GetNetworkSendRateBps() float64 {
	if x != nil {
		return x.NetworkSendRateBps
	}
	return 0
}

func (x *SystemStats) GetNetworkRecvRateBps() float64 {
	if x != nil {
		return x.NetworkRecvRateBps
	}
	return 0
}

func (x *SystemStats) GetGpus() []*GPUStats {
	if x != nil {
		return x.Gpus
	}
	return nil
}

func (x *SystemStats) GetCpuPressure() *PressureStats {
	if x != nil {
		return x.CpuPressure
	}
	return nil
}

func (x *SystemStats) GetMemoryPressure() *PressureStats {
	if x != nil {
		return x.MemoryPressure
	}
	return nil
}

func (x *SystemStats) GetIoPressure() *PressureStats {
	if x != nil {
		return x.IoPressure
	}
	return nil
}

type GPUStats struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Index              int32                  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Name               string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DriverVersion      string                 `protobuf:"bytes,3,opt,name=driver_version,json=driverVersion,proto3" json:"driver_version,omitempty"`
	UtilizationPercent float64                `protobuf:"fixed64,4,opt,name=utilization_percent,json=utilizationPercent,proto3" json:"utilization_percent,omitempty"`
	MemoryPercent      float64                `protobuf:"fixed64,5,opt,name=memory_percent,json=memoryPercent,proto3" json:"memory_percent,omitempty"`
	MemoryTotalBytes   uint64                 `protobuf:"varint,6,opt,name=memory_total_bytes,json=memoryTotalBytes,proto3" json:"memory_total_bytes,omitempty"`
	MemoryUsedBytes    uint64                 `protobuf:"varint,7,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	TemperatureCelsius int32                  `protobuf:"varint,8,opt,name=temperature_celsius,json=temperatureCelsius,proto3" json:"temperature_celsius,omitempty"`
	PowerWatts         int32                  `protobuf:"varint,9,opt,name=power_watts,json=powerWatts,proto3" json:"power_watts,omitempty"`
	EncoderUtilization float64                `protobuf:"fixed64,10,opt,name=encoder_utilization,json=encoderUtilization,proto3" json:"encoder_utilization,omitempty"`
	DecoderUtilization float64                `protobuf:"fixed64,11,opt,name=decoder_utilization,json=decoderUtilization,proto3" json:"decoder_utilization,omitempty"`
	// Session tracking (updated in real-time)
	MaxEncodeSessions    int32    `protobuf:"varint,12,opt,name=max_encode_sessions,json=maxEncodeSessions,proto3" json:"max_encode_sessions,omitempty"`
	ActiveEncodeSessions int32    `protobuf:"varint,13,opt,name=active_encode_sessions,json=activeEncodeSessions,proto3" json:"active_encode_sessions,omitempty"`
	MaxDecodeSessions    int32    `protobuf:"varint,14,opt,name=max_decode_sessions,json=maxDecodeSessions,proto3" json:"max_decode_sessions,omitempty"`
	ActiveDecodeSessions int32    `protobuf:"varint,15,opt,name=active_decode_sessions,json=activeDecodeSessions,proto3" json:"active_decode_sessions,omitempty"`
	GpuClass             GPUClass `protobuf:"varint,16,opt,name=gpu_class,json=gpuClass,proto3,enum=ffmpegd.GPUClass" json:"gpu_class,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *GPUStats) Reset() {
	*x = GPUStats{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GPUStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GPUStats) ProtoMessage() {}

func (x *GPUStats) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GPUStats.ProtoReflect.Descriptor instead.
func (*GPUStats) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{15}
}

func (x *GPUStats) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *GPUStats) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GPUStats) GetDriverVersion() string {
	if x != nil {
		return x.DriverVersion
	}
	return ""
}

func (x *GPUStats) GetUtilizationPercent() float64 {
	if x != nil {
		return x.UtilizationPercent
	}
	return 0
}

func (x *GPUStats) GetMemoryPercent() float64 {
	if x != nil {
		return x.MemoryPercent
	}
	return 0
}

func (x *GPUStats) GetMemoryTotalBytes() uint64 {
	if x != nil {
		return x.MemoryTotalBytes
	}
	return 0
}

func (x *GPUStats) GetMemoryUsedBytes() uint64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *GPUStats) GetTemperatureCelsius() int32 {
	if x != nil {
		return x.TemperatureCelsius
	}
	return 0
}

func (x *GPUStats) GetPowerWatts() int32 {
	if x != nil {
		return x.PowerWatts
	}
	return 0
}

func (x *GPUStats) GetEncoderUtilization() float64 {
	if x != nil {
		return x.EncoderUtilization
	}
	return 0
}

func (x *GPUStats) GetDecoderUtilization() float64 {
	if x != nil {
		return x.DecoderUtilization
	}
	return 0
}

func (x *GPUStats) GetMaxEncodeSessions() int32 {
	if x != nil {
		return x.MaxEncodeSessions
	}
	return 0
}

func (x *GPUStats) GetActiveEncodeSessions() int32 {
	if x != nil {
		return x.ActiveEncodeSessions
	}
	return 0
}

func (x *GPUStats) GetMaxDecodeSessions() int32 {
	if x != nil {
		return x.MaxDecodeSessions
	}
	return 0
}

func (x *GPUStats) GetActiveDecodeSessions() int32 {
	if x != nil {
		return x.ActiveDecodeSessions
	}
	return 0
}

func (x *GPUStats) GetGpuClass() GPUClass {
	if x != nil {
		return x.GpuClass
	}
	return GPUClass_GPU_CLASS_UNKNOWN
}

type PressureStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Avg10         float64                `protobuf:"fixed64,1,opt,name=avg10,proto3" json:"avg10,omitempty"`                   // 10-second average
	Avg60         float64                `protobuf:"fixed64,2,opt,name=avg60,proto3" json:"avg60,omitempty"`                   // 60-second average
	Avg300        float64                `protobuf:"fixed64,3,opt,name=avg300,proto3" json:"avg300,omitempty"`                 // 5-minute average
	TotalUs       uint64                 `protobuf:"varint,4,opt,name=total_us,json=totalUs,proto3" json:"total_us,omitempty"` // Total stall time in microseconds
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PressureStats) Reset() {
	*x = PressureStats{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PressureStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PressureStats) ProtoMessage() {}

func (x *PressureStats) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PressureStats.ProtoReflect.Descriptor instead.
func (*PressureStats) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{16}
}

func (x *PressureStats) GetAvg10() float64 {
	if x != nil {
		return x.Avg10
	}
	return 0
}

func (x *PressureStats) GetAvg60() float64 {
	if x != nil {
		return x.Avg60
	}
	return 0
}

func (x *PressureStats) GetAvg300() float64 {
	if x != nil {
		return x.Avg300
	}
	return 0
}

func (x *PressureStats) GetTotalUs() uint64 {
	if x != nil {
		return x.TotalUs
	}
	return 0
}

// TranscodeMessage is the bidirectional streaming message for transcoding.
// Flow:
//  1. Client sends TranscodeStart (config)
//  2. Daemon sends TranscodeAck (acknowledged)
//  3. Client sends ESSampleBatch (source samples, is_source=true)
//  4. Daemon sends ESSampleBatch (transcoded samples, is_source=false)
//  5. Daemon sends TranscodeStats periodically
//  6. Client sends TranscodeStop when done
type TranscodeMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*TranscodeMessage_Start
	//	*TranscodeMessage_Ack
	//	*TranscodeMessage_Samples
	//	*TranscodeMessage_Stats
	//	*TranscodeMessage_Error
	//	*TranscodeMessage_Stop
	//	*TranscodeMessage_InputComplete
	Payload       isTranscodeMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeMessage) Reset() {
	*x = TranscodeMessage{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeMessage) ProtoMessage() {}

func (x *TranscodeMessage) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeMessage.ProtoReflect.Descriptor instead.
func (*TranscodeMessage) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{17}
}

func (x *TranscodeMessage) GetPayload() isTranscodeMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *TranscodeMessage) GetStart() *TranscodeStart {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Start); ok {
			return x.Start
		}
	}
	return nil
}

func (x *TranscodeMessage) GetAck() *TranscodeAck {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Ack); ok {
			return x.Ack
		}
	}
	return nil
}

func (x *TranscodeMessage) GetSamples() *ESSampleBatch {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Samples); ok {
			return x.Samples
		}
	}
	return nil
}

func (x *TranscodeMessage) GetStats() *TranscodeStats {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Stats); ok {
			return x.Stats
		}
	}
	return nil
}

func (x *TranscodeMessage) GetError() *TranscodeError {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *TranscodeMessage) GetStop() *TranscodeStop {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

func (x *TranscodeMessage) GetInputComplete() *TranscodeInputComplete {
	if x != nil {
		if x, ok := x.Payload.(*TranscodeMessage_InputComplete); ok {
			return x.InputComplete
		}
	}
	return nil
}

type isTranscodeMessage_Payload interface {
	isTranscodeMessage_Payload()
}

type TranscodeMessage_Start struct {
	Start *TranscodeStart `protobuf:"bytes,1,opt,name=start,proto3,oneof"` // Initial config (client -> daemon)
}

type TranscodeMessage_Ack struct {
	Ack *TranscodeAck `protobuf:"bytes,2,opt,name=ack,proto3,oneof"` // Acknowledge start (daemon -> client)
}

type TranscodeMessage_Samples struct {
	Samples *ESSampleBatch `protobuf:"bytes,3,opt,name=samples,proto3,oneof"` // ES samples (bidirectional)
}

type TranscodeMessage_Stats struct {
	Stats *TranscodeStats `protobuf:"bytes,4,opt,name=stats,proto3,oneof"` // Periodic stats (daemon -> client)
}

type TranscodeMessage_Error struct {
	Error *TranscodeError `protobuf:"bytes,5,opt,name=error,proto3,oneof"` // Error notification (daemon -> client)
}

type TranscodeMessage_Stop struct {
	Stop *TranscodeStop `protobuf:"bytes,6,opt,name=stop,proto3,oneof"` // Stop signal (client -> daemon)
}

type TranscodeMessage_InputComplete struct {
	InputComplete *TranscodeInputComplete `protobuf:"bytes,7,opt,name=input_complete,json=inputComplete,proto3,oneof"` // Input complete signal (client -> daemon)
}

func (*TranscodeMessage_Start) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_Ack) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_Samples) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_Stats) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_Error) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_Stop) isTranscodeMessage_Payload() {}

func (*TranscodeMessage_InputComplete) isTranscodeMessage_Payload() {}

type TranscodeStart struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Job identification
	JobId       string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	SessionId   string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ChannelId   string `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	ChannelName string `protobuf:"bytes,4,opt,name=channel_name,json=channelName,proto3" json:"channel_name,omitempty"`
	// Source codec information
	SourceVideoCodec string `protobuf:"bytes,5,opt,name=source_video_codec,json=sourceVideoCodec,proto3" json:"source_video_codec,omitempty"` // h264, hevc, vp9, av1
	SourceAudioCodec string `protobuf:"bytes,6,opt,name=source_audio_codec,json=sourceAudioCodec,proto3" json:"source_audio_codec,omitempty"` // aac, ac3, eac3, mp3
	VideoInitData    []byte `protobuf:"bytes,7,opt,name=video_init_data,json=videoInitData,proto3" json:"video_init_data,omitempty"`          // SPS/PPS for H.264, VPS/SPS/PPS for HEVC
	AudioInitData    []byte `protobuf:"bytes,8,opt,name=audio_init_data,json=audioInitData,proto3" json:"audio_init_data,omitempty"`          // AudioSpecificConfig
	// Target codec configuration (from EncodingProfile)
	TargetVideoCodec string `protobuf:"bytes,9,opt,name=target_video_codec,json=targetVideoCodec,proto3" json:"target_video_codec,omitempty"`  // Required: h264, hevc, vp9, av1
	TargetAudioCodec string `protobuf:"bytes,10,opt,name=target_audio_codec,json=targetAudioCodec,proto3" json:"target_audio_codec,omitempty"` // Required: aac, ac3, opus, mp3
	// Encoding parameters
	VideoBitrateKbps int32  `protobuf:"varint,13,opt,name=video_bitrate_kbps,json=videoBitrateKbps,proto3" json:"video_bitrate_kbps,omitempty"`
	AudioBitrateKbps int32  `protobuf:"varint,14,opt,name=audio_bitrate_kbps,json=audioBitrateKbps,proto3" json:"audio_bitrate_kbps,omitempty"`
	VideoPreset      string `protobuf:"bytes,15,opt,name=video_preset,json=videoPreset,proto3" json:"video_preset,omitempty"`    // ultrafast, fast, medium, slow
	VideoCrf         int32  `protobuf:"varint,16,opt,name=video_crf,json=videoCrf,proto3" json:"video_crf,omitempty"`            // Quality-based encoding (0-51)
	VideoProfile     string `protobuf:"bytes,17,opt,name=video_profile,json=videoProfile,proto3" json:"video_profile,omitempty"` // baseline, main, high
	VideoLevel       string `protobuf:"bytes,18,opt,name=video_level,json=videoLevel,proto3" json:"video_level,omitempty"`       // 3.0, 4.0, 4.1, etc.
	// Hardware acceleration preference
	PreferredHwAccel string `protobuf:"bytes,19,opt,name=preferred_hw_accel,json=preferredHwAccel,proto3" json:"preferred_hw_accel,omitempty"` // vaapi, cuda, qsv (empty = auto)
	HwDevice         string `protobuf:"bytes,20,opt,name=hw_device,json=hwDevice,proto3" json:"hw_device,omitempty"`                           // /dev/dri/renderD128
	// Resolution scaling (optional)
	ScaleWidth  int32 `protobuf:"varint,21,opt,name=scale_width,json=scaleWidth,proto3" json:"scale_width,omitempty"` // 0 = no scaling
	ScaleHeight int32 `protobuf:"varint,22,opt,name=scale_height,json=scaleHeight,proto3" json:"scale_height,omitempty"`
	// Additional FFmpeg options (advanced)
	ExtraOptions map[string]string `protobuf:"bytes,23,rep,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Custom FFmpeg flags from encoding profile
	InputFlags  string `protobuf:"bytes,24,opt,name=input_flags,json=inputFlags,proto3" json:"input_flags,omitempty"`    // Flags placed before -i input
	OutputFlags string `protobuf:"bytes,25,opt,name=output_flags,json=outputFlags,proto3" json:"output_flags,omitempty"` // Flags placed after -i input
	GlobalFlags string `protobuf:"bytes,26,opt,name=global_flags,json=globalFlags,proto3" json:"global_flags,omitempty"` // Global FFmpeg flags
	// Encoder override rules (from coordinator database)
	// Applied by daemon to force specific encoders when conditions match
	EncoderOverrides []*EncoderOverride `protobuf:"bytes,27,rep,name=encoder_overrides,json=encoderOverrides,proto3" json:"encoder_overrides,omitempty"`
	// Output container format for FFmpeg
	// Values: "fmp4" (fragmented MP4), "mpegts" (MPEG Transport Stream)
	// Default: auto-select based on target codec (fmp4 for av1/vp9, mpegts for h264/h265)
	// This determines the daemon's FFmpeg output format and demuxer selection.
	OutputContainerFormat string `protobuf:"bytes,28,opt,name=output_container_format,json=outputContainerFormat,proto3" json:"output_container_format,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *TranscodeStart) Reset() {
	*x = TranscodeStart{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeStart) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeStart) ProtoMessage() {}

func (x *TranscodeStart) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeStart.ProtoReflect.Descriptor instead.
func (*TranscodeStart) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{18}
}

func (x *TranscodeStart) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *TranscodeStart) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *TranscodeStart) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

func (x *TranscodeStart) GetChannelName() string {
	if x != nil {
		return x.ChannelName
	}
	return ""
}

func (x *TranscodeStart) GetSourceVideoCodec() string {
	if x != nil {
		return x.SourceVideoCodec
	}
	return ""
}

func (x *TranscodeStart) GetSourceAudioCodec() string {
	if x != nil {
		return x.SourceAudioCodec
	}
	return ""
}

func (x *TranscodeStart) GetVideoInitData() []byte {
	if x != nil {
		return x.VideoInitData
	}
	return nil
}

func (x *TranscodeStart) GetAudioInitData() []byte {
	if x != nil {
		return x.AudioInitData
	}
	return nil
}

func (x *TranscodeStart) GetTargetVideoCodec() string {
	if x != nil {
		return x.TargetVideoCodec
	}
	return ""
}

func (x *TranscodeStart) GetTargetAudioCodec() string {
	if x != nil {
		return x.TargetAudioCodec
	}
	return ""
}

func (x *TranscodeStart) GetVideoBitrateKbps() int32 {
	if x != nil {
		return x.VideoBitrateKbps
	}
	return 0
}

func (x *TranscodeStart) GetAudioBitrateKbps() int32 {
	if x != nil {
		return x.AudioBitrateKbps
	}
	return 0
}

func (x *TranscodeStart) GetVideoPreset() string {
	if x != nil {
		return x.VideoPreset
	}
	return ""
}

func (x *TranscodeStart) GetVideoCrf() int32 {
	if x != nil {
		return x.VideoCrf
	}
	return 0
}

func (x *TranscodeStart) GetVideoProfile() string {
	if x != nil {
		return x.VideoProfile
	}
	return ""
}

func (x *TranscodeStart) GetVideoLevel() string {
	if x != nil {
		return x.VideoLevel
	}
	return ""
}

func (x *TranscodeStart) GetPreferredHwAccel() string {
	if x != nil {
		return x.PreferredHwAccel
	}
	return ""
}

func (x *TranscodeStart) GetHwDevice() string {
	if x != nil {
		return x.HwDevice
	}
	return ""
}

func (x *TranscodeStart) GetScaleWidth() int32 {
	if x != nil {
		return x.ScaleWidth
	}
	return 0
}

func (x *TranscodeStart) GetScaleHeight() int32 {
	if x != nil {
		return x.ScaleHeight
	}
	return 0
}

func (x *TranscodeStart) GetExtraOptions() map[string]string {
	if x != nil {
		return x.ExtraOptions
	}
	return nil
}

func (x *TranscodeStart) GetInputFlags() string {
	if x != nil {
		return x.InputFlags
	}
	return ""
}

func (x *TranscodeStart) GetOutputFlags() string {
	if x != nil {
		return x.OutputFlags
	}
	return ""
}

func (x *TranscodeStart) GetGlobalFlags() string {
	if x != nil {
		return x.GlobalFlags
	}
	return ""
}

func (x *TranscodeStart) GetEncoderOverrides() []*EncoderOverride {
	if x != nil {
		return x.EncoderOverrides
	}
	return nil
}

func (x *TranscodeStart) GetOutputContainerFormat() string {
	if x != nil {
		return x.OutputContainerFormat
	}
	return ""
}

// EncoderOverride allows forcing specific encoders when conditions match.
// This is used to work around hardware encoder bugs (e.g., AMD hevc_vaapi with Mesa 21.1+).
type EncoderOverride struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Codec type: "video" or "audio"
	CodecType string `protobuf:"bytes,1,opt,name=codec_type,json=codecType,proto3" json:"codec_type,omitempty"`
	// Source codec to match (e.g., "h265", "aac")
	SourceCodec string `protobuf:"bytes,2,opt,name=source_codec,json=sourceCodec,proto3" json:"source_codec,omitempty"`
	// Encoder to use when this override matches (e.g., "libx265", "libopus")
	TargetEncoder string `protobuf:"bytes,3,opt,name=target_encoder,json=targetEncoder,proto3" json:"target_encoder,omitempty"`
	// Optional: Hardware accelerator to match (e.g., "vaapi", "cuda")
	// Empty string matches all hardware accelerators
	HwAccelMatch string `protobuf:"bytes,4,opt,name=hw_accel_match,json=hwAccelMatch,proto3" json:"hw_accel_match,omitempty"`
	// Optional: CPU regex pattern to match (e.g., "AMD")
	// Empty string matches all CPUs
	CpuMatch string `protobuf:"bytes,5,opt,name=cpu_match,json=cpuMatch,proto3" json:"cpu_match,omitempty"`
	// Priority for ordering (higher = evaluated first)
	Priority      int32 `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncoderOverride) Reset() {
	*x = EncoderOverride{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncoderOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncoderOverride) ProtoMessage() {}

func (x *EncoderOverride) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncoderOverride.ProtoReflect.Descriptor instead.
func (*EncoderOverride) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{19}
}

func (x *EncoderOverride) GetCodecType() string {
	if x != nil {
		return x.CodecType
	}
	return ""
}

func (x *EncoderOverride) GetSourceCodec() string {
	if x != nil {
		return x.SourceCodec
	}
	return ""
}

func (x *EncoderOverride) GetTargetEncoder() string {
	if x != nil {
		return x.TargetEncoder
	}
	return ""
}

func (x *EncoderOverride) GetHwAccelMatch() string {
	if x != nil {
		return x.HwAccelMatch
	}
	return ""
}

func (x *EncoderOverride) GetCpuMatch() string {
	if x != nil {
		return x.CpuMatch
	}
	return ""
}

func (x *EncoderOverride) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

type TranscodeAck struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Actual configuration used (may differ from requested)
	ActualVideoEncoder string `protobuf:"bytes,3,opt,name=actual_video_encoder,json=actualVideoEncoder,proto3" json:"actual_video_encoder,omitempty"`
	ActualAudioEncoder string `protobuf:"bytes,4,opt,name=actual_audio_encoder,json=actualAudioEncoder,proto3" json:"actual_audio_encoder,omitempty"`
	ActualHwAccel      string `protobuf:"bytes,5,opt,name=actual_hw_accel,json=actualHwAccel,proto3" json:"actual_hw_accel,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TranscodeAck) Reset() {
	*x = TranscodeAck{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeAck) ProtoMessage() {}

func (x *TranscodeAck) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeAck.ProtoReflect.Descriptor instead.
func (*TranscodeAck) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{20}
}

func (x *TranscodeAck) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *TranscodeAck) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *TranscodeAck) GetActualVideoEncoder() string {
	if x != nil {
		return x.ActualVideoEncoder
	}
	return ""
}

func (x *TranscodeAck) GetActualAudioEncoder() string {
	if x != nil {
		return x.ActualAudioEncoder
	}
	return ""
}

func (x *TranscodeAck) GetActualHwAccel() string {
	if x != nil {
		return x.ActualHwAccel
	}
	return ""
}

// ESSampleBatch groups elementary stream samples for efficient transport
type ESSampleBatch struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	VideoSamples []*ESSample            `protobuf:"bytes,1,rep,name=video_samples,json=videoSamples,proto3" json:"video_samples,omitempty"`
	AudioSamples []*ESSample            `protobuf:"bytes,2,rep,name=audio_samples,json=audioSamples,proto3" json:"audio_samples,omitempty"`
	// Direction indicator
	IsSource bool `protobuf:"varint,3,opt,name=is_source,json=isSource,proto3" json:"is_source,omitempty"` // true = source samples from coordinator
	// Batch sequence for ordering
	BatchSequence uint64 `protobuf:"varint,4,opt,name=batch_sequence,json=batchSequence,proto3" json:"batch_sequence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ESSampleBatch) Reset() {
	*x = ESSampleBatch{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ESSampleBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ESSampleBatch) ProtoMessage() {}

func (x *ESSampleBatch) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ESSampleBatch.ProtoReflect.Descriptor instead.
func (*ESSampleBatch) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{21}
}

func (x *ESSampleBatch) GetVideoSamples() []*ESSample {
	if x != nil {
		return x.VideoSamples
	}
	return nil
}

func (x *ESSampleBatch) GetAudioSamples() []*ESSample {
	if x != nil {
		return x.AudioSamples
	}
	return nil
}

func (x *ESSampleBatch) GetIsSource() bool {
	if x != nil {
		return x.IsSource
	}
	return false
}

func (x *ESSampleBatch) GetBatchSequence() uint64 {
	if x != nil {
		return x.BatchSequence
	}
	return 0
}

// ESSample represents a single elementary stream sample
type ESSample struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pts           int64                  `protobuf:"varint,1,opt,name=pts,proto3" json:"pts,omitempty"`                                 // Presentation timestamp (90kHz timescale)
	Dts           int64                  `protobuf:"varint,2,opt,name=dts,proto3" json:"dts,omitempty"`                                 // Decode timestamp (90kHz timescale)
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`                                // NAL unit (video) or audio frame
	IsKeyframe    bool                   `protobuf:"varint,4,opt,name=is_keyframe,json=isKeyframe,proto3" json:"is_keyframe,omitempty"` // True for IDR frames / sync points
	Sequence      uint64                 `protobuf:"varint,5,opt,name=sequence,proto3" json:"sequence,omitempty"`                       // Sample sequence number for ordering
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ESSample) Reset() {
	*x = ESSample{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ESSample) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ESSample) ProtoMessage() {}

func (x *ESSample) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ESSample.ProtoReflect.Descriptor instead.
func (*ESSample) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{22}
}

func (x *ESSample) GetPts() int64 {
	if x != nil {
		return x.Pts
	}
	return 0
}

func (x *ESSample) GetDts() int64 {
	if x != nil {
		return x.Dts
	}
	return 0
}

func (x *ESSample) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ESSample) GetIsKeyframe() bool {
	if x != nil {
		return x.IsKeyframe
	}
	return false
}

func (x *ESSample) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

type TranscodeStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SamplesIn     uint64                 `protobuf:"varint,1,opt,name=samples_in,json=samplesIn,proto3" json:"samples_in,omitempty"`              // Total source samples received
	SamplesOut    uint64                 `protobuf:"varint,2,opt,name=samples_out,json=samplesOut,proto3" json:"samples_out,omitempty"`           // Total transcoded samples produced
	BytesIn       uint64                 `protobuf:"varint,3,opt,name=bytes_in,json=bytesIn,proto3" json:"bytes_in,omitempty"`                    // Total source bytes
	BytesOut      uint64                 `protobuf:"varint,4,opt,name=bytes_out,json=bytesOut,proto3" json:"bytes_out,omitempty"`                 // Total transcoded bytes
	EncodingSpeed float64                `protobuf:"fixed64,5,opt,name=encoding_speed,json=encodingSpeed,proto3" json:"encoding_speed,omitempty"` // Speed relative to realtime (1.0 = realtime)
	CpuPercent    float64                `protobuf:"fixed64,6,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`          // FFmpeg process CPU usage
	MemoryMb      float64                `protobuf:"fixed64,7,opt,name=memory_mb,json=memoryMb,proto3" json:"memory_mb,omitempty"`                // FFmpeg process memory
	FfmpegPid     int32                  `protobuf:"varint,8,opt,name=ffmpeg_pid,json=ffmpegPid,proto3" json:"ffmpeg_pid,omitempty"`              // FFmpeg process ID
	RunningTime   *durationpb.Duration   `protobuf:"bytes,9,opt,name=running_time,json=runningTime,proto3" json:"running_time,omitempty"`
	// Hardware acceleration info for this job
	HwAccel  string `protobuf:"bytes,10,opt,name=hw_accel,json=hwAccel,proto3" json:"hw_accel,omitempty"`    // vaapi, cuda, qsv, videotoolbox (empty = software)
	HwDevice string `protobuf:"bytes,11,opt,name=hw_device,json=hwDevice,proto3" json:"hw_device,omitempty"` // Device path: /dev/dri/renderD128, cuda:0, etc.
	// FFmpeg command for debugging
	FfmpegCommand string `protobuf:"bytes,12,opt,name=ffmpeg_command,json=ffmpegCommand,proto3" json:"ffmpeg_command,omitempty"` // Full FFmpeg command line being executed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeStats) Reset() {
	*x = TranscodeStats{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeStats) ProtoMessage() {}

func (x *TranscodeStats) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeStats.ProtoReflect.Descriptor instead.
func (*TranscodeStats) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{23}
}

func (x *TranscodeStats) GetSamplesIn() uint64 {
	if x != nil {
		return x.SamplesIn
	}
	return 0
}

func (x *TranscodeStats) GetSamplesOut() uint64 {
	if x != nil {
		return x.SamplesOut
	}
	return 0
}

func (x *TranscodeStats) GetBytesIn() uint64 {
	if x != nil {
		return x.BytesIn
	}
	return 0
}

func (x *TranscodeStats) GetBytesOut() uint64 {
	if x != nil {
		return x.BytesOut
	}
	return 0
}

func (x *TranscodeStats) GetEncodingSpeed() float64 {
	if x != nil {
		return x.EncodingSpeed
	}
	return 0
}

func (x *TranscodeStats) GetCpuPercent() float64 {
	if x != nil {
		return x.CpuPercent
	}
	return 0
}

func (x *TranscodeStats) GetMemoryMb() float64 {
	if x != nil {
		return x.MemoryMb
	}
	return 0
}

func (x *TranscodeStats) GetFfmpegPid() int32 {
	if x != nil {
		return x.FfmpegPid
	}
	return 0
}

func (x *TranscodeStats) GetRunningTime() *durationpb.Duration {
	if x != nil {
		return x.RunningTime
	}
	return nil
}

func (x *TranscodeStats) GetHwAccel() string {
	if x != nil {
		return x.HwAccel
	}
	return ""
}

func (x *TranscodeStats) GetHwDevice() string {
	if x != nil {
		return x.HwDevice
	}
	return ""
}

func (x *TranscodeStats) GetFfmpegCommand() string {
	if x != nil {
		return x.FfmpegCommand
	}
	return ""
}

type TranscodeError struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Code          TranscodeError_ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=ffmpegd.TranscodeError_ErrorCode" json:"code,omitempty"`
	Message       string                   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	FfmpegStderr  string                   `protobuf:"bytes,3,opt,name=ffmpeg_stderr,json=ffmpegStderr,proto3" json:"ffmpeg_stderr,omitempty"` // Last N lines of FFmpeg stderr
	Recoverable   bool                     `protobuf:"varint,4,opt,name=recoverable,proto3" json:"recoverable,omitempty"`                      // Can retry with fallback?
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeError) Reset() {
	*x = TranscodeError{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeError) ProtoMessage() {}

func (x *TranscodeError) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeError.ProtoReflect.Descriptor instead.
func (*TranscodeError) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{24}
}

func (x *TranscodeError) GetCode() TranscodeError_ErrorCode {
	if x != nil {
		return x.Code
	}
	return TranscodeError_ERROR_UNSPECIFIED
}

func (x *TranscodeError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *TranscodeError) GetFfmpegStderr() string {
	if x != nil {
		return x.FfmpegStderr
	}
	return ""
}

func (x *TranscodeError) GetRecoverable() bool {
	if x != nil {
		return x.Recoverable
	}
	return false
}

type TranscodeStop struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Reason        string                 `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"` // "session_ended", "client_disconnected", "cancelled"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeStop) Reset() {
	*x = TranscodeStop{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeStop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeStop) ProtoMessage() {}

func (x *TranscodeStop) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeStop.ProtoReflect.Descriptor instead.
func (*TranscodeStop) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{25}
}

func (x *TranscodeStop) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// TranscodeInputComplete signals that all input has been sent (source EOF).
// This allows the daemon to let FFmpeg flush its encoder and produce remaining
// output, without immediately killing the FFmpeg process.
// Unlike TranscodeStop, this is a graceful signal - the daemon continues
// reading FFmpeg output until it naturally finishes.
type TranscodeInputComplete struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Reason for input completion (for logging)
	Reason        string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"` // "source_eof", "stream_ended"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeInputComplete) Reset() {
	*x = TranscodeInputComplete{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeInputComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeInputComplete) ProtoMessage() {}

func (x *TranscodeInputComplete) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeInputComplete.ProtoReflect.Descriptor instead.
func (*TranscodeInputComplete) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{26}
}

func (x *TranscodeInputComplete) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type GetStatsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	DaemonId          string                 `protobuf:"bytes,1,opt,name=daemon_id,json=daemonId,proto3" json:"daemon_id,omitempty"`
	IncludeJobDetails bool                   `protobuf:"varint,2,opt,name=include_job_details,json=includeJobDetails,proto3" json:"include_job_details,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GetStatsRequest) Reset() {
	*x = GetStatsRequest{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatsRequest) ProtoMessage() {}

func (x *GetStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatsRequest.ProtoReflect.Descriptor instead.
func (*GetStatsRequest) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{27}
}

func (x *GetStatsRequest) GetDaemonId() string {
	if x != nil {
		return x.DaemonId
	}
	return ""
}

func (x *GetStatsRequest) GetIncludeJobDetails() bool {
	if x != nil {
		return x.IncludeJobDetails
	}
	return false
}

type GetStatsResponse struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Capabilities *Capabilities          `protobuf:"bytes,1,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	SystemStats  *SystemStats           `protobuf:"bytes,2,opt,name=system_stats,json=systemStats,proto3" json:"system_stats,omitempty"`
	ActiveJobs   []*JobStatus           `protobuf:"bytes,3,rep,name=active_jobs,json=activeJobs,proto3" json:"active_jobs,omitempty"`
	// Aggregate stats
	TotalJobsCompleted  uint64               `protobuf:"varint,4,opt,name=total_jobs_completed,json=totalJobsCompleted,proto3" json:"total_jobs_completed,omitempty"`
	TotalJobsFailed     uint64               `protobuf:"varint,5,opt,name=total_jobs_failed,json=totalJobsFailed,proto3" json:"total_jobs_failed,omitempty"`
	TotalBytesProcessed uint64               `protobuf:"varint,6,opt,name=total_bytes_processed,json=totalBytesProcessed,proto3" json:"total_bytes_processed,omitempty"`
	TotalEncodingTime   *durationpb.Duration `protobuf:"bytes,7,opt,name=total_encoding_time,json=totalEncodingTime,proto3" json:"total_encoding_time,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GetStatsResponse) Reset() {
	*x = GetStatsResponse{}
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatsResponse) ProtoMessage() {}

func (x *GetStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatsResponse.ProtoReflect.Descriptor instead.
func (*GetStatsResponse) Descriptor() ([]byte, []int) {
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP(), []int{28}
}

func (x *GetStatsResponse) GetCapabilities() *Capabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *GetStatsResponse) GetSystemStats() *SystemStats {
	if x != nil {
		return x.SystemStats
	}
	return nil
}

func (x *GetStatsResponse) GetActiveJobs() []*JobStatus {
	if x != nil {
		return x.ActiveJobs
	}
	return nil
}

func (x *GetStatsResponse) GetTotalJobsCompleted() uint64 {
	if x != nil {
		return x.TotalJobsCompleted
	}
	return 0
}

func (x *GetStatsResponse) GetTotalJobsFailed() uint64 {
	if x != nil {
		return x.TotalJobsFailed
	}
	return 0
}

func (x *GetStatsResponse) GetTotalBytesProcessed() uint64 {
	if x != nil {
		return x.TotalBytesProcessed
	}
	return 0
}

func (x *GetStatsResponse) GetTotalEncodingTime() *durationpb.Duration {
	if x != nil {
		return x.TotalEncodingTime
	}
	return nil
}

var File_pkg_ffmpegd_proto_ffmpegd_proto protoreflect.FileDescriptor

const file_pkg_ffmpegd_proto_ffmpegd_proto_rawDesc = "" +
	"\n" +
	"\x1fpkg/ffmpegd/proto/ffmpegd.proto\x12\affmpegd\x1a\x1egoogle/protobuf/duration.proto\"\xc3\x01\n" +
	"\x0fRegisterRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x12\x1f\n" +
	"\vdaemon_name\x18\x02 \x01(\tR\n" +
	"daemonName\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x129\n" +
	"\fcapabilities\x18\x04 \x01(\v2\x15.ffmpegd.CapabilitiesR\fcapabilities\x12\x1d\n" +
	"\n" +
	"auth_token\x18\x05 \x01(\tR\tauthToken\"\xbd\x01\n" +
	"\x10RegisterResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12H\n" +
	"\x12heartbeat_interval\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x11heartbeatInterval\x12/\n" +
	"\x13coordinator_version\x18\x04 \x01(\tR\x12coordinatorVersion\"H\n" +
	"\x11UnregisterRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\".\n" +
	"\x12UnregisterResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\"\x9d\x01\n" +
	"\x10HeartbeatRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x127\n" +
	"\fsystem_stats\x18\x02 \x01(\v2\x14.ffmpegd.SystemStatsR\vsystemStats\x123\n" +
	"\vactive_jobs\x18\x03 \x03(\v2\x12.ffmpegd.JobStatusR\n" +
	"activeJobs\"a\n" +
	"\x11HeartbeatResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x122\n" +
	"\bcommands\x18\x02 \x03(\v2\x16.ffmpegd.DaemonCommandR\bcommands\"\xe9\x01\n" +
	"\rDaemonCommand\x126\n" +
	"\x04type\x18\x01 \x01(\x0e2\".ffmpegd.DaemonCommand.CommandTypeR\x04type\x12\x15\n" +
	"\x06job_id\x18\x02 \x01(\tR\x05jobId\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\"o\n" +
	"\vCommandType\x12\x17\n" +
	"\x13COMMAND_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05DRAIN\x10\x01\x12\n" +
	"\n" +
	"\x06RESUME\x10\x02\x12\x0e\n" +
	"\n" +
	"CANCEL_JOB\x10\x03\x12\x11\n" +
	"\rUPDATE_CONFIG\x10\x04\x12\r\n" +
	"\tSTART_JOB\x10\x05\"\x95\x03\n" +
	"\x12TranscodeJobConfig\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x03 \x01(\tR\tchannelId\x12!\n" +
	"\fchannel_name\x18\x04 \x01(\tR\vchannelName\x12,\n" +
	"\x12target_video_codec\x18\x05 \x01(\tR\x10targetVideoCodec\x12,\n" +
	"\x12target_audio_codec\x18\x06 \x01(\tR\x10targetAudioCodec\x12,\n" +
	"\x12video_bitrate_kbps\x18\a \x01(\x05R\x10videoBitrateKbps\x12,\n" +
	"\x12audio_bitrate_kbps\x18\b \x01(\x05R\x10audioBitrateKbps\x12!\n" +
	"\fvideo_preset\x18\t \x01(\tR\vvideoPreset\x12,\n" +
	"\x12preferred_hw_accel\x18\n" +
	" \x01(\tR\x10preferredHwAccel\"\xd1\x01\n" +
	"\tJobStatus\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12!\n" +
	"\fchannel_name\x18\x03 \x01(\tR\vchannelName\x12-\n" +
	"\x05stats\x18\x04 \x01(\v2\x17.ffmpegd.TranscodeStatsR\x05stats\x12<\n" +
	"\frunning_time\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\vrunningTime\"\xf2\x02\n" +
	"\fCapabilities\x121\n" +
	"\thw_accels\x18\x01 \x03(\v2\x14.ffmpegd.HWAccelInfoR\bhwAccels\x12$\n" +
	"\x04gpus\x18\x02 \x03(\v2\x10.ffmpegd.GPUInfoR\x04gpus\x12%\n" +
	"\x0evideo_encoders\x18\x03 \x03(\tR\rvideoEncoders\x12%\n" +
	"\x0evideo_decoders\x18\x04 \x03(\tR\rvideoDecoders\x12%\n" +
	"\x0eaudio_encoders\x18\x05 \x03(\tR\raudioEncoders\x12%\n" +
	"\x0eaudio_decoders\x18\x06 \x03(\tR\raudioDecoders\x12.\n" +
	"\x13max_concurrent_jobs\x18\a \x01(\x05R\x11maxConcurrentJobs\x12=\n" +
	"\vperformance\x18\b \x01(\v2\x1b.ffmpegd.PerformanceMetricsR\vperformance\"\xe0\x01\n" +
	"\vHWAccelInfo\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x16\n" +
	"\x06device\x18\x02 \x01(\tR\x06device\x12\x1c\n" +
	"\tavailable\x18\x03 \x01(\bR\tavailable\x12\x1f\n" +
	"\vhw_encoders\x18\x04 \x03(\tR\n" +
	"hwEncoders\x12\x1f\n" +
	"\vhw_decoders\x18\x05 \x03(\tR\n" +
	"hwDecoders\x12E\n" +
	"\x11filtered_encoders\x18\x06 \x03(\v2\x18.ffmpegd.FilteredEncoderR\x10filteredEncoders\"=\n" +
	"\x0fFilteredEncoder\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"\x95\x05\n" +
	"\aGPUInfo\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x05R\x05index\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12.\n" +
	"\tgpu_class\x18\x03 \x01(\x0e2\x11.ffmpegd.GPUClassR\bgpuClass\x12%\n" +
	"\x0edriver_version\x18\x04 \x01(\tR\rdriverVersion\x12.\n" +
	"\x13max_encode_sessions\x18\x05 \x01(\x05R\x11maxEncodeSessions\x12.\n" +
	"\x13max_decode_sessions\x18\x06 \x01(\x05R\x11maxDecodeSessions\x124\n" +
	"\x16active_encode_sessions\x18\a \x01(\x05R\x14activeEncodeSessions\x124\n" +
	"\x16active_decode_sessions\x18\b \x01(\x05R\x14activeDecodeSessions\x12/\n" +
	"\x13utilization_percent\x18\t \x01(\x01R\x12utilizationPercent\x12,\n" +
	"\x12memory_total_bytes\x18\n" +
	" \x01(\x04R\x10memoryTotalBytes\x12*\n" +
	"\x11memory_used_bytes\x18\v \x01(\x04R\x0fmemoryUsedBytes\x12/\n" +
	"\x13encoder_utilization\x18\f \x01(\x01R\x12encoderUtilization\x12/\n" +
	"\x13decoder_utilization\x18\r \x01(\x01R\x12decoderUtilization\x12/\n" +
	"\x13temperature_celsius\x18\x0e \x01(\x05R\x12temperatureCelsius\x12\x1f\n" +
	"\vpower_watts\x18\x0f \x01(\x05R\n" +
	"powerWatts\"\x9a\x01\n" +
	"\x12PerformanceMetrics\x12$\n" +
	"\x0eh264_1080p_fps\x18\x01 \x01(\x01R\fh2641080pFps\x12$\n" +
	"\x0eh265_1080p_fps\x18\x02 \x01(\x01R\fh2651080pFps\x12\x1b\n" +
	"\tmemory_gb\x18\x03 \x01(\x01R\bmemoryGb\x12\x1b\n" +
	"\tcpu_cores\x18\x04 \x01(\x05R\bcpuCores\"\x84\t\n" +
	"\vSystemStats\x12\x1a\n" +
	"\bhostname\x18\x01 \x01(\tR\bhostname\x12\x0e\n" +
	"\x02os\x18\x02 \x01(\tR\x02os\x12\x12\n" +
	"\x04arch\x18\x03 \x01(\tR\x04arch\x12%\n" +
	"\x0euptime_seconds\x18\x04 \x01(\x03R\ruptimeSeconds\x12\x1b\n" +
	"\tcpu_cores\x18\x05 \x01(\x05R\bcpuCores\x12\x1f\n" +
	"\vcpu_percent\x18\x06 \x01(\x01R\n" +
	"cpuPercent\x12 \n" +
	"\fcpu_per_core\x18\a \x03(\x01R\n" +
	"cpuPerCore\x12\x1e\n" +
	"\vload_avg_1m\x18\b \x01(\x01R\tloadAvg1m\x12\x1e\n" +
	"\vload_avg_5m\x18\t \x01(\x01R\tloadAvg5m\x12 \n" +
	"\fload_avg_15m\x18\n" +
	" \x01(\x01R\n" +
	"loadAvg15m\x12,\n" +
	"\x12memory_total_bytes\x18\v \x01(\x04R\x10memoryTotalBytes\x12*\n" +
	"\x11memory_used_bytes\x18\f \x01(\x04R\x0fmemoryUsedBytes\x124\n" +
	"\x16memory_available_bytes\x18\r \x01(\x04R\x14memoryAvailableBytes\x12%\n" +
	"\x0ememory_percent\x18\x0e \x01(\x01R\rmemoryPercent\x12(\n" +
	"\x10swap_total_bytes\x18\x0f \x01(\x04R\x0eswapTotalBytes\x12&\n" +
	"\x0fswap_used_bytes\x18\x10 \x01(\x04R\rswapUsedBytes\x12(\n" +
	"\x10disk_total_bytes\x18\x11 \x01(\x04R\x0ediskTotalBytes\x12&\n" +
	"\x0fdisk_used_bytes\x18\x12 \x01(\x04R\rdiskUsedBytes\x120\n" +
	"\x14disk_available_bytes\x18\x13 \x01(\x04R\x12diskAvailableBytes\x12!\n" +
	"\fdisk_percent\x18\x14 \x01(\x01R\vdiskPercent\x12,\n" +
	"\x12network_bytes_sent\x18\x15 \x01(\x04R\x10networkBytesSent\x12,\n" +
	"\x12network_bytes_recv\x18\x16 \x01(\x04R\x10networkBytesRecv\x121\n" +
	"\x15network_send_rate_bps\x18\x17 \x01(\x01R\x12networkSendRateBps\x121\n" +
	"\x15network_recv_rate_bps\x18\x18 \x01(\x01R\x12networkRecvRateBps\x12%\n" +
	"\x04gpus\x18\x19 \x03(\v2\x11.ffmpegd.GPUStatsR\x04gpus\x129\n" +
	"\fcpu_pressure\x18\x1a \x01(\v2\x16.ffmpegd.PressureStatsR\vcpuPressure\x12?\n" +
	"\x0fmemory_pressure\x18\x1b \x01(\v2\x16.ffmpegd.PressureStatsR\x0ememoryPressure\x127\n" +
	"\vio_pressure\x18\x1c \x01(\v2\x16.ffmpegd.PressureStatsR\n" +
	"ioPressure\"\xbd\x05\n" +
	"\bGPUStats\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x05R\x05index\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12%\n" +
	"\x0edriver_version\x18\x03 \x01(\tR\rdriverVersion\x12/\n" +
	"\x13utilization_percent\x18\x04 \x01(\x01R\x12utilizationPercent\x12%\n" +
	"\x0ememory_percent\x18\x05 \x01(\x01R\rmemoryPercent\x12,\n" +
	"\x12memory_total_bytes\x18\x06 \x01(\x04R\x10memoryTotalBytes\x12*\n" +
	"\x11memory_used_bytes\x18\a \x01(\x04R\x0fmemoryUsedBytes\x12/\n" +
	"\x13temperature_celsius\x18\b \x01(\x05R\x12temperatureCelsius\x12\x1f\n" +
	"\vpower_watts\x18\t \x01(\x05R\n" +
	"powerWatts\x12/\n" +
	"\x13encoder_utilization\x18\n" +
	" \x01(\x01R\x12encoderUtilization\x12/\n" +
	"\x13decoder_utilization\x18\v \x01(\x01R\x12decoderUtilization\x12.\n" +
	"\x13max_encode_sessions\x18\f \x01(\x05R\x11maxEncodeSessions\x124\n" +
	"\x16active_encode_sessions\x18\r \x01(\x05R\x14activeEncodeSessions\x12.\n" +
	"\x13max_decode_sessions\x18\x0e \x01(\x05R\x11maxDecodeSessions\x124\n" +
	"\x16active_decode_sessions\x18\x0f \x01(\x05R\x14activeDecodeSessions\x12.\n" +
	"\tgpu_class\x18\x10 \x01(\x0e2\x11.ffmpegd.GPUClassR\bgpuClass\"n\n" +
	"\rPressureStats\x12\x14\n" +
	"\x05avg10\x18\x01 \x01(\x01R\x05avg10\x12\x14\n" +
	"\x05avg60\x18\x02 \x01(\x01R\x05avg60\x12\x16\n" +
	"\x06avg300\x18\x03 \x01(\x01R\x06avg300\x12\x19\n" +
	"\btotal_us\x18\x04 \x01(\x04R\atotalUs\"\x87\x03\n" +
	"\x10TranscodeMessage\x12/\n" +
	"\x05start\x18\x01 \x01(\v2\x17.ffmpegd.TranscodeStartH\x00R\x05start\x12)\n" +
	"\x03ack\x18\x02 \x01(\v2\x15.ffmpegd.TranscodeAckH\x00R\x03ack\x122\n" +
	"\asamples\x18\x03 \x01(\v2\x16.ffmpegd.ESSampleBatchH\x00R\asamples\x12/\n" +
	"\x05stats\x18\x04 \x01(\v2\x17.ffmpegd.TranscodeStatsH\x00R\x05stats\x12/\n" +
	"\x05error\x18\x05 \x01(\v2\x17.ffmpegd.TranscodeErrorH\x00R\x05error\x12,\n" +
	"\x04stop\x18\x06 \x01(\v2\x16.ffmpegd.TranscodeStopH\x00R\x04stop\x12H\n" +
	"\x0einput_complete\x18\a \x01(\v2\x1f.ffmpegd.TranscodeInputCompleteH\x00R\rinputCompleteB\t\n" +
	"\apayload\"\x84\t\n" +
	"\x0eTranscodeStart\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x03 \x01(\tR\tchannelId\x12!\n" +
	"\fchannel_name\x18\x04 \x01(\tR\vchannelName\x12,\n" +
	"\x12source_video_codec\x18\x05 \x01(\tR\x10sourceVideoCodec\x12,\n" +
	"\x12source_audio_codec\x18\x06 \x01(\tR\x10sourceAudioCodec\x12&\n" +
	"\x0fvideo_init_data\x18\a \x01(\fR\rvideoInitData\x12&\n" +
	"\x0faudio_init_data\x18\b \x01(\fR\raudioInitData\x12,\n" +
	"\x12target_video_codec\x18\t \x01(\tR\x10targetVideoCodec\x12,\n" +
	"\x12target_audio_codec\x18\n" +
	" \x01(\tR\x10targetAudioCodec\x12,\n" +
	"\x12video_bitrate_kbps\x18\r \x01(\x05R\x10videoBitrateKbps\x12,\n" +
	"\x12audio_bitrate_kbps\x18\x0e \x01(\x05R\x10audioBitrateKbps\x12!\n" +
	"\fvideo_preset\x18\x0f \x01(\tR\vvideoPreset\x12\x1b\n" +
	"\tvideo_crf\x18\x10 \x01(\x05R\bvideoCrf\x12#\n" +
	"\rvideo_profile\x18\x11 \x01(\tR\fvideoProfile\x12\x1f\n" +
	"\vvideo_level\x18\x12 \x01(\tR\n" +
	"videoLevel\x12,\n" +
	"\x12preferred_hw_accel\x18\x13 \x01(\tR\x10preferredHwAccel\x12\x1b\n" +
	"\thw_device\x18\x14 \x01(\tR\bhwDevice\x12\x1f\n" +
	"\vscale_width\x18\x15 \x01(\x05R\n" +
	"scaleWidth\x12!\n" +
	"\fscale_height\x18\x16 \x01(\x05R\vscaleHeight\x12N\n" +
	"\rextra_options\x18\x17 \x03(\v2).ffmpegd.TranscodeStart.ExtraOptionsEntryR\fextraOptions\x12\x1f\n" +
	"\vinput_flags\x18\x18 \x01(\tR\n" +
	"inputFlags\x12!\n" +
	"\foutput_flags\x18\x19 \x01(\tR\voutputFlags\x12!\n" +
	"\fglobal_flags\x18\x1a \x01(\tR\vglobalFlags\x12E\n" +
	"\x11encoder_overrides\x18\x1b \x03(\v2\x18.ffmpegd.EncoderOverrideR\x10encoderOverrides\x126\n" +
	"\x17output_container_format\x18\x1c \x01(\tR\x15outputContainerFormat\x1a?\n" +
	"\x11ExtraOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\v\x10\fJ\x04\b\f\x10\r\"\xd9\x01\n" +
	"\x0fEncoderOverride\x12\x1d\n" +
	"\n" +
	"codec_type\x18\x01 \x01(\tR\tcodecType\x12!\n" +
	"\fsource_codec\x18\x02 \x01(\tR\vsourceCodec\x12%\n" +
	"\x0etarget_encoder\x18\x03 \x01(\tR\rtargetEncoder\x12$\n" +
	"\x0ehw_accel_match\x18\x04 \x01(\tR\fhwAccelMatch\x12\x1b\n" +
	"\tcpu_match\x18\x05 \x01(\tR\bcpuMatch\x12\x1a\n" +
	"\bpriority\x18\x06 \x01(\x05R\bpriority\"\xca\x01\n" +
	"\fTranscodeAck\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x120\n" +
	"\x14actual_video_encoder\x18\x03 \x01(\tR\x12actualVideoEncoder\x120\n" +
	"\x14actual_audio_encoder\x18\x04 \x01(\tR\x12actualAudioEncoder\x12&\n" +
	"\x0factual_hw_accel\x18\x05 \x01(\tR\ractualHwAccel\"\xc3\x01\n" +
	"\rESSampleBatch\x126\n" +
	"\rvideo_samples\x18\x01 \x03(\v2\x11.ffmpegd.ESSampleR\fvideoSamples\x126\n" +
	"\raudio_samples\x18\x02 \x03(\v2\x11.ffmpegd.ESSampleR\faudioSamples\x12\x1b\n" +
	"\tis_source\x18\x03 \x01(\bR\bisSource\x12%\n" +
	"\x0ebatch_sequence\x18\x04 \x01(\x04R\rbatchSequence\"\x7f\n" +
	"\bESSample\x12\x10\n" +
	"\x03pts\x18\x01 \x01(\x03R\x03pts\x12\x10\n" +
	"\x03dts\x18\x02 \x01(\x03R\x03dts\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x1f\n" +
	"\vis_keyframe\x18\x04 \x01(\bR\n" +
	"isKeyframe\x12\x1a\n" +
	"\bsequence\x18\x05 \x01(\x04R\bsequence\"\xa9\x03\n" +
	"\x0eTranscodeStats\x12\x1d\n" +
	"\n" +
	"samples_in\x18\x01 \x01(\x04R\tsamplesIn\x12\x1f\n" +
	"\vsamples_out\x18\x02 \x01(\x04R\n" +
	"samplesOut\x12\x19\n" +
	"\bbytes_in\x18\x03 \x01(\x04R\abytesIn\x12\x1b\n" +
	"\tbytes_out\x18\x04 \x01(\x04R\bbytesOut\x12%\n" +
	"\x0eencoding_speed\x18\x05 \x01(\x01R\rencodingSpeed\x12\x1f\n" +
	"\vcpu_percent\x18\x06 \x01(\x01R\n" +
	"cpuPercent\x12\x1b\n" +
	"\tmemory_mb\x18\a \x01(\x01R\bmemoryMb\x12\x1d\n" +
	"\n" +
	"ffmpeg_pid\x18\b \x01(\x05R\tffmpegPid\x12<\n" +
	"\frunning_time\x18\t \x01(\v2\x19.google.protobuf.DurationR\vrunningTime\x12\x19\n" +
	"\bhw_accel\x18\n" +
	" \x01(\tR\ahwAccel\x12\x1b\n" +
	"\thw_device\x18\v \x01(\tR\bhwDevice\x12%\n" +
	"\x0effmpeg_command\x18\f \x01(\tR\rffmpegCommand\"\xe1\x02\n" +
	"\x0eTranscodeError\x125\n" +
	"\x04code\x18\x01 \x01(\x0e2!.ffmpegd.TranscodeError.ErrorCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12#\n" +
	"\rffmpeg_stderr\x18\x03 \x01(\tR\fffmpegStderr\x12 \n" +
	"\vrecoverable\x18\x04 \x01(\bR\vrecoverable\"\xb6\x01\n" +
	"\tErrorCode\x12\x15\n" +
	"\x11ERROR_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13FFMPEG_START_FAILED\x10\x01\x12\x12\n" +
	"\x0eFFMPEG_CRASHED\x10\x02\x12\x15\n" +
	"\x11CODEC_UNSUPPORTED\x10\x03\x12\x13\n" +
	"\x0fHW_ACCEL_FAILED\x10\x04\x12\x19\n" +
	"\x15SESSION_LIMIT_REACHED\x10\x05\x12\x11\n" +
	"\rOUT_OF_MEMORY\x10\x06\x12\v\n" +
	"\aTIMEOUT\x10\a\"'\n" +
	"\rTranscodeStop\x12\x16\n" +
	"\x06reason\x18\x01 \x01(\tR\x06reason\"0\n" +
	"\x16TranscodeInputComplete\x12\x16\n" +
	"\x06reason\x18\x01 \x01(\tR\x06reason\"^\n" +
	"\x0fGetStatsRequest\x12\x1b\n" +
	"\tdaemon_id\x18\x01 \x01(\tR\bdaemonId\x12.\n" +
	"\x13include_job_details\x18\x02 \x01(\bR\x11includeJobDetails\"\x98\x03\n" +
	"\x10GetStatsResponse\x129\n" +
	"\fcapabilities\x18\x01 \x01(\v2\x15.ffmpegd.CapabilitiesR\fcapabilities\x127\n" +
	"\fsystem_stats\x18\x02 \x01(\v2\x14.ffmpegd.SystemStatsR\vsystemStats\x123\n" +
	"\vactive_jobs\x18\x03 \x03(\v2\x12.ffmpegd.JobStatusR\n" +
	"activeJobs\x120\n" +
	"\x14total_jobs_completed\x18\x04 \x01(\x04R\x12totalJobsCompleted\x12*\n" +
	"\x11total_jobs_failed\x18\x05 \x01(\x04R\x0ftotalJobsFailed\x122\n" +
	"\x15total_bytes_processed\x18\x06 \x01(\x04R\x13totalBytesProcessed\x12I\n" +
	"\x13total_encoding_time\x18\a \x01(\v2\x19.google.protobuf.DurationR\x11totalEncodingTime*\x89\x01\n" +
	"\bGPUClass\x12\x15\n" +
	"\x11GPU_CLASS_UNKNOWN\x10\x00\x12\x16\n" +
	"\x12GPU_CLASS_CONSUMER\x10\x01\x12\x1a\n" +
	"\x16GPU_CLASS_PROFESSIONAL\x10\x02\x12\x18\n" +
	"\x14GPU_CLASS_DATACENTER\x10\x03\x12\x18\n" +
	"\x14GPU_CLASS_INTEGRATED\x10\x042\xe2\x02\n" +
	"\fFFmpegDaemon\x12?\n" +
	"\bRegister\x12\x18.ffmpegd.RegisterRequest\x1a\x19.ffmpegd.RegisterResponse\x12B\n" +
	"\tHeartbeat\x12\x19.ffmpegd.HeartbeatRequest\x1a\x1a.ffmpegd.HeartbeatResponse\x12E\n" +
	"\n" +
	"Unregister\x12\x1a.ffmpegd.UnregisterRequest\x1a\x1b.ffmpegd.UnregisterResponse\x12E\n" +
	"\tTranscode\x12\x19.ffmpegd.TranscodeMessage\x1a\x19.ffmpegd.TranscodeMessage(\x010\x01\x12?\n" +
	"\bGetStats\x12\x18.ffmpegd.GetStatsRequest\x1a\x19.ffmpegd.GetStatsResponseB0Z.github.com/jmylchreest/tvarr/pkg/ffmpegd/protob\x06proto3"

var (
	file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescOnce sync.Once
	file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescData []byte
)

func file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescGZIP() []byte {
	file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescOnce.Do(func() {
		file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pkg_ffmpegd_proto_ffmpegd_proto_rawDesc), len(file_pkg_ffmpegd_proto_ffmpegd_proto_rawDesc)))
	})
	return file_pkg_ffmpegd_proto_ffmpegd_proto_rawDescData
}

var file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_pkg_ffmpegd_proto_ffmpegd_proto_goTypes = []any{
	(GPUClass)(0),                  // 0: ffmpegd.GPUClass
	(DaemonCommand_CommandType)(0), // 1: ffmpegd.DaemonCommand.CommandType
	(TranscodeError_ErrorCode)(0),  // 2: ffmpegd.TranscodeError.ErrorCode
	(*RegisterRequest)(nil),        // 3: ffmpegd.RegisterRequest
	(*RegisterResponse)(nil),       // 4: ffmpegd.RegisterResponse
	(*UnregisterRequest)(nil),      // 5: ffmpegd.UnregisterRequest
	(*UnregisterResponse)(nil),     // 6: ffmpegd.UnregisterResponse
	(*HeartbeatRequest)(nil),       // 7: ffmpegd.HeartbeatRequest
	(*HeartbeatResponse)(nil),      // 8: ffmpegd.HeartbeatResponse
	(*DaemonCommand)(nil),          // 9: ffmpegd.DaemonCommand
	(*TranscodeJobConfig)(nil),     // 10: ffmpegd.TranscodeJobConfig
	(*JobStatus)(nil),              // 11: ffmpegd.JobStatus
	(*Capabilities)(nil),           // 12: ffmpegd.Capabilities
	(*HWAccelInfo)(nil),            // 13: ffmpegd.HWAccelInfo
	(*FilteredEncoder)(nil),        // 14: ffmpegd.FilteredEncoder
	(*GPUInfo)(nil),                // 15: ffmpegd.GPUInfo
	(*PerformanceMetrics)(nil),     // 16: ffmpegd.PerformanceMetrics
	(*SystemStats)(nil),            // 17: ffmpegd.SystemStats
	(*GPUStats)(nil),               // 18: ffmpegd.GPUStats
	(*PressureStats)(nil),          // 19: ffmpegd.PressureStats
	(*TranscodeMessage)(nil),       // 20: ffmpegd.TranscodeMessage
	(*TranscodeStart)(nil),         // 21: ffmpegd.TranscodeStart
	(*EncoderOverride)(nil),        // 22: ffmpegd.EncoderOverride
	(*TranscodeAck)(nil),           // 23: ffmpegd.TranscodeAck
	(*ESSampleBatch)(nil),          // 24: ffmpegd.ESSampleBatch
	(*ESSample)(nil),               // 25: ffmpegd.ESSample
	(*TranscodeStats)(nil),         // 26: ffmpegd.TranscodeStats
	(*TranscodeError)(nil),         // 27: ffmpegd.TranscodeError
	(*TranscodeStop)(nil),          // 28: ffmpegd.TranscodeStop
	(*TranscodeInputComplete)(nil), // 29: ffmpegd.TranscodeInputComplete
	(*GetStatsRequest)(nil),        // 30: ffmpegd.GetStatsRequest
	(*GetStatsResponse)(nil),       // 31: ffmpegd.GetStatsResponse
	nil,                            // 32: ffmpegd.TranscodeStart.ExtraOptionsEntry
	(*durationpb.Duration)(nil),    // 33: google.protobuf.Duration
}
var file_pkg_ffmpegd_proto_ffmpegd_proto_depIdxs = []int32{
	12, // 0: ffmpegd.RegisterRequest.capabilities:type_name -> ffmpegd.Capabilities
	33, // 1: ffmpegd.RegisterResponse.heartbeat_interval:type_name -> google.protobuf.Duration
	17, // 2: ffmpegd.HeartbeatRequest.system_stats:type_name -> ffmpegd.SystemStats
	11, // 3: ffmpegd.HeartbeatRequest.active_jobs:type_name -> ffmpegd.JobStatus
	9,  // 4: ffmpegd.HeartbeatResponse.commands:type_name -> ffmpegd.DaemonCommand
	1,  // 5: ffmpegd.DaemonCommand.type:type_name -> ffmpegd.DaemonCommand.CommandType
	26, // 6: ffmpegd.JobStatus.stats:type_name -> ffmpegd.TranscodeStats
	33, // 7: ffmpegd.JobStatus.running_time:type_name -> google.protobuf.Duration
	13, // 8: ffmpegd.Capabilities.hw_accels:type_name -> ffmpegd.HWAccelInfo
	15, // 9: ffmpegd.Capabilities.gpus:type_name -> ffmpegd.GPUInfo
	16, // 10: ffmpegd.Capabilities.performance:type_name -> ffmpegd.PerformanceMetrics
	14, // 11: ffmpegd.HWAccelInfo.filtered_encoders:type_name -> ffmpegd.FilteredEncoder
	0,  // 12: ffmpegd.GPUInfo.gpu_class:type_name -> ffmpegd.GPUClass
	18, // 13: ffmpegd.SystemStats.gpus:type_name -> ffmpegd.GPUStats
	19, // 14: ffmpegd.SystemStats.cpu_pressure:type_name -> ffmpegd.PressureStats
	19, // 15: ffmpegd.SystemStats.memory_pressure:type_name -> ffmpegd.PressureStats
	19, // 16: ffmpegd.SystemStats.io_pressure:type_name -> ffmpegd.PressureStats
	0,  // 17: ffmpegd.GPUStats.gpu_class:type_name -> ffmpegd.GPUClass
	21, // 18: ffmpegd.TranscodeMessage.start:type_name -> ffmpegd.TranscodeStart
	23, // 19: ffmpegd.TranscodeMessage.ack:type_name -> ffmpegd.TranscodeAck
	24, // 20: ffmpegd.TranscodeMessage.samples:type_name -> ffmpegd.ESSampleBatch
	26, // 21: ffmpegd.TranscodeMessage.stats:type_name -> ffmpegd.TranscodeStats
	27, // 22: ffmpegd.TranscodeMessage.error:type_name -> ffmpegd.TranscodeError
	28, // 23: ffmpegd.TranscodeMessage.stop:type_name -> ffmpegd.TranscodeStop
	29, // 24: ffmpegd.TranscodeMessage.input_complete:type_name -> ffmpegd.TranscodeInputComplete
	32, // 25: ffmpegd.TranscodeStart.extra_options:type_name -> ffmpegd.TranscodeStart.ExtraOptionsEntry
	22, // 26: ffmpegd.TranscodeStart.encoder_overrides:type_name -> ffmpegd.EncoderOverride
	25, // 27: ffmpegd.ESSampleBatch.video_samples:type_name -> ffmpegd.ESSample
	25, // 28: ffmpegd.ESSampleBatch.audio_samples:type_name -> ffmpegd.ESSample
	33, // 29: ffmpegd.TranscodeStats.running_time:type_name -> google.protobuf.Duration
	2,  // 30: ffmpegd.TranscodeError.code:type_name -> ffmpegd.TranscodeError.ErrorCode
	12, // 31: ffmpegd.GetStatsResponse.capabilities:type_name -> ffmpegd.Capabilities
	17, // 32: ffmpegd.GetStatsResponse.system_stats:type_name -> ffmpegd.SystemStats
	11, // 33: ffmpegd.GetStatsResponse.active_jobs:type_name -> ffmpegd.JobStatus
	33, // 34: ffmpegd.GetStatsResponse.total_encoding_time:type_name -> google.protobuf.Duration
	3,  // 35: ffmpegd.FFmpegDaemon.Register:input_type -> ffmpegd.RegisterRequest
	7,  // 36: ffmpegd.FFmpegDaemon.Heartbeat:input_type -> ffmpegd.HeartbeatRequest
	5,  // 37: ffmpegd.FFmpegDaemon.Unregister:input_type -> ffmpegd.UnregisterRequest
	20, // 38: ffmpegd.FFmpegDaemon.Transcode:input_type -> ffmpegd.TranscodeMessage
	30, // 39: ffmpegd.FFmpegDaemon.GetStats:input_type -> ffmpegd.GetStatsRequest
	4,  // 40: ffmpegd.FFmpegDaemon.Register:output_type -> ffmpegd.RegisterResponse
	8,  // 41: ffmpegd.FFmpegDaemon.Heartbeat:output_type -> ffmpegd.HeartbeatResponse
	6,  // 42: ffmpegd.FFmpegDaemon.Unregister:output_type -> ffmpegd.UnregisterResponse
	20, // 43: ffmpegd.FFmpegDaemon.Transcode:output_type -> ffmpegd.TranscodeMessage
	31, // 44: ffmpegd.FFmpegDaemon.GetStats:output_type -> ffmpegd.GetStatsResponse
	40, // [40:45] is the sub-list for method output_type
	35, // [35:40] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_pkg_ffmpegd_proto_ffmpegd_proto_init() }
func file_pkg_ffmpegd_proto_ffmpegd_proto_init() {
	if File_pkg_ffmpegd_proto_ffmpegd_proto != nil {
		return
	}
	file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes[17].OneofWrappers = []any{
		(*TranscodeMessage_Start)(nil),
		(*TranscodeMessage_Ack)(nil),
		(*TranscodeMessage_Samples)(nil),
		(*TranscodeMessage_Stats)(nil),
		(*TranscodeMessage_Error)(nil),
		(*TranscodeMessage_Stop)(nil),
		(*TranscodeMessage_InputComplete)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pkg_ffmpegd_proto_ffmpegd_proto_rawDesc), len(file_pkg_ffmpegd_proto_ffmpegd_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_pkg_ffmpegd_proto_ffmpegd_proto_goTypes,
		DependencyIndexes: file_pkg_ffmpegd_proto_ffmpegd_proto_depIdxs,
		EnumInfos:         file_pkg_ffmpegd_proto_ffmpegd_proto_enumTypes,
		MessageInfos:      file_pkg_ffmpegd_proto_ffmpegd_proto_msgTypes,
	}.Build()
	File_pkg_ffmpegd_proto_ffmpegd_proto = out.File
	file_pkg_ffmpegd_proto_ffmpegd_proto_goTypes = nil
	file_pkg_ffmpegd_proto_ffmpegd_proto_depIdxs = nil
}
