# https://taskfile.dev
#
# NOTE: This Taskfile uses POSIX shell commands and requires bash/sh.
# Windows users should use WSL, Git Bash, or rely on GitHub Actions for builds.

version: "3"

vars:
  BINARY_NAME: tvarr
  DIST_DIR: dist
  DEBUG_DIR: "{{.DIST_DIR}}/debug"
  RELEASE_DIR: "{{.DIST_DIR}}/release"
  MODULE: github.com/jmylchreest/tvarr
  VERSION_PKG: "{{.MODULE}}/internal/version"
  FRONTEND_DIR: frontend
  ASSETS_DIR: internal/assets/static

  # Version detection: Docker ENV vars (TVARR_BUILD_*) take priority over git
  # This allows Docker builds to inject version info since .git is excluded
  # Format: X.Y.Z for releases, X.Y.Z-dev.N-HASH for dev builds (using - not + for GitHub compatibility)
  VERSION:
    sh: |
      if [ -n "${TVARR_BUILD_VERSION:-}" ]; then
        echo "$TVARR_BUILD_VERSION"
      elif TAG=$(git describe --tags --exact-match 2>/dev/null); then
        # On an exact tag - use it directly
        echo "$TAG" | sed 's/^v//'
      else
        # Find latest release tag (only vX.Y.Z, no prerelease)
        LATEST_RELEASE=$(git tag --list 'v*' 2>/dev/null | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)
        SHORT_SHA=$(git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown")
        if [ -n "$LATEST_RELEASE" ]; then
          # Count commits since latest release
          COMMITS=$(git rev-list "${LATEST_RELEASE}..HEAD" --count 2>/dev/null || echo "0")
          # Parse and increment patch version
          VERSION_NUM="${LATEST_RELEASE#v}"
          MAJOR=$(echo "$VERSION_NUM" | cut -d. -f1)
          MINOR=$(echo "$VERSION_NUM" | cut -d. -f2)
          PATCH=$(echo "$VERSION_NUM" | cut -d. -f3)
          NEXT_PATCH=$((PATCH + 1))
          echo "${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}-${SHORT_SHA}"
        else
          # No release tags found - use 0.0.1-dev.0-HASH
          echo "0.0.1-dev.0-${SHORT_SHA}"
        fi
      fi
  COMMIT:
    sh: echo "${TVARR_BUILD_COMMIT:-$(git rev-parse HEAD 2>/dev/null || echo unknown)}"
  SHORT_SHA:
    sh: git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown"
  BUILD_DATE:
    sh: echo "${TVARR_BUILD_DATE:-$(date -u '+%Y-%m-%dT%H:%M:%SZ')}"
  BRANCH:
    sh: echo "${TVARR_BUILD_BRANCH:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo unknown)}"
  TREE_STATE:
    sh: echo "${TVARR_BUILD_TREE_STATE:-$(git diff --quiet 2>/dev/null && echo clean || echo dirty)}"

  # Docker/OCI tag-safe version (replaces + with - since + is invalid in tags)
  VERSION_TAG:
    sh: echo "{{.VERSION}}" | tr '+' '-'

  # LDFLAGS for version injection (aligned with GitHub Actions)
  LDFLAGS: >-
    -s -w
    -X {{.VERSION_PKG}}.Version={{.VERSION}}
    -X {{.VERSION_PKG}}.Commit={{.COMMIT}}
    -X {{.VERSION_PKG}}.Date={{.BUILD_DATE}}
    -X {{.VERSION_PKG}}.Branch={{.BRANCH}}
    -X {{.VERSION_PKG}}.TreeState={{.TREE_STATE}}

  COVERAGE_FILE: coverage.out

  # Container runtime detection (docker, podman, nerdctl)
  # Override with CONTAINER_RUNTIME env var or task variable
  CONTAINER_RUNTIME:
    sh: |
      if [ -n "${CONTAINER_RUNTIME:-}" ]; then echo "$CONTAINER_RUNTIME"
      elif command -v podman >/dev/null 2>&1; then echo "podman"
      elif command -v docker >/dev/null 2>&1; then echo "docker"
      elif command -v nerdctl >/dev/null 2>&1; then echo "nerdctl"
      else echo "docker"
      fi

  # Local architecture detection for container builds
  LOCAL_ARCH:
    sh: |
      arch=$(uname -m)
      case "$arch" in
        x86_64|amd64) echo "linux/amd64" ;;
        aarch64|arm64) echo "linux/arm64" ;;
        armv7l) echo "linux/arm/v7" ;;
        *) echo "linux/$arch" ;;
      esac

  # FFmpeg Dockerfile hash (first 8 chars of sha256) - matches CI workflow
  FFMPEG_DOCKERFILE_HASH:
    sh: sha256sum deployment/docker/Dockerfile.ffmpeg | cut -c1-8

tasks:
  default:
    desc: Run lint, test, and build
    cmds:
      - task: lint
      - task: test
      - task: build

  # ============================================
  # Build Tasks
  # ============================================

  build:
    desc: Build the application binary (debug, uncompressed)
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    cmds:
      - mkdir -p {{.DEBUG_DIR}}
      - go build -ldflags "{{.LDFLAGS}}" -o {{.DEBUG_DIR}}/{{.BINARY_NAME}} ./cmd/tvarr
    sources:
      - ./**/*.go
      - go.mod
      - go.sum
    generates:
      - "{{.DEBUG_DIR}}/{{.BINARY_NAME}}"

  build:ffmpegd:
    desc: Build the tvarr-ffmpegd daemon binary (debug, uncompressed)
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    cmds:
      - mkdir -p {{.DEBUG_DIR}}
      - go build -ldflags "{{.LDFLAGS}}" -o {{.DEBUG_DIR}}/tvarr-ffmpegd ./cmd/tvarr-ffmpegd
    sources:
      - ./**/*.go
      - go.mod
      - go.sum
    generates:
      - "{{.DEBUG_DIR}}/tvarr-ffmpegd"

  build:linux:amd64:
    desc: Cross-compile for Linux amd64
    env:
      CGO_ENABLED: "0"
      GOOS: linux
      GOARCH: amd64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_linux_amd64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_linux_amd64/{{.BINARY_NAME}} ./cmd/tvarr

  build:linux:arm64:
    desc: Cross-compile for Linux arm64
    env:
      CGO_ENABLED: "0"
      GOOS: linux
      GOARCH: arm64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_linux_arm64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_linux_arm64/{{.BINARY_NAME}} ./cmd/tvarr

  build:darwin:amd64:
    desc: Cross-compile for macOS amd64
    env:
      CGO_ENABLED: "0"
      GOOS: darwin
      GOARCH: amd64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_darwin_amd64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_darwin_amd64/{{.BINARY_NAME}} ./cmd/tvarr

  build:darwin:arm64:
    desc: Cross-compile for macOS arm64 (Apple Silicon)
    env:
      CGO_ENABLED: "0"
      GOOS: darwin
      GOARCH: arm64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_darwin_arm64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_darwin_arm64/{{.BINARY_NAME}} ./cmd/tvarr

  build:windows:amd64:
    desc: Cross-compile for Windows amd64
    env:
      CGO_ENABLED: "0"
      GOOS: windows
      GOARCH: amd64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_windows_amd64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_windows_amd64/{{.BINARY_NAME}}.exe ./cmd/tvarr

  build:windows:arm64:
    desc: Cross-compile for Windows arm64
    env:
      CGO_ENABLED: "0"
      GOOS: windows
      GOARCH: arm64
    cmds:
      - mkdir -p {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_windows_arm64
      - go build -ldflags "{{.LDFLAGS}}" -o {{.RELEASE_DIR}}/{{.BINARY_NAME}}_{{.VERSION}}_windows_arm64/{{.BINARY_NAME}}.exe ./cmd/tvarr

  build:all:
    desc: Build for all platforms (matches GitHub Actions matrix)
    cmds:
      - task: build:linux:amd64
      - task: build:linux:arm64
      - task: build:darwin:amd64
      - task: build:darwin:arm64
      - task: build:windows:amd64
      - task: build:windows:arm64

  # ============================================
  # Container Tasks (supports docker, podman, nerdctl)
  # ============================================

  container:build:
    desc: Build all container images (FFmpeg base + tvarr + ffmpegd + coordinator)
    summary: |
      Builds all container images: FFmpeg base, tvarr (full), ffmpegd daemon, and coordinator (slim).
      Auto-detects container runtime ({{.CONTAINER_RUNTIME}}) and platform ({{.LOCAL_ARCH}}).

      Options:
        - PLATFORM: Target platform (default: auto-detected {{.LOCAL_ARCH}})
        - TAG: Image tag (default: latest)

      For individual builds, use:
        - task container:build:ffmpeg      (FFmpeg base image)
        - task container:build:tvarr       (full tvarr with local FFmpeg)
        - task container:build:ffmpegd     (distributed transcoding daemon)
        - task container:build:coordinator (slim coordinator without FFmpeg)
    cmds:
      - task: container:build:ffmpeg
      - task: container:build:tvarr
      - task: container:build:ffmpegd
      - task: container:build:coordinator

  container:build:tvarr:
    desc: Build tvarr application container image (with FFmpeg)
    summary: |
      Builds the full tvarr container image based on tvarr-ffmpeg.
      Includes FFmpeg with hardware acceleration for local transcoding.
      Auto-detects container runtime ({{.CONTAINER_RUNTIME}}) and platform ({{.LOCAL_ARCH}}).

      Options:
        - PLATFORM: Target platform (default: auto-detected {{.LOCAL_ARCH}})
        - TAG: Image tag (default: latest)
        - FFMPEG_IMAGE: FFmpeg base image (default: ghcr.io/jmylchreest/tvarr-ffmpeg:latest)
        - LOCAL: Use local images only, don't pull from registry (default: false)

      Local builds also create a version-tagged image ({{.VERSION}}).

      For a slim coordinator-only image (no local FFmpeg), use:
        task container:build:coordinator
    vars:
      TAG: '{{.TAG | default "latest"}}'
      PLATFORM: '{{.PLATFORM | default .LOCAL_ARCH}}'
      FFMPEG_IMAGE: '{{.FFMPEG_IMAGE | default "ghcr.io/jmylchreest/tvarr-ffmpeg:latest"}}'
      LOCAL: '{{.LOCAL | default "false"}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} build \
          -f deployment/docker/Dockerfile \
          --platform {{.PLATFORM}} \
          $([ "{{.LOCAL}}" = "true" ] && echo "--pull=never") \
          --build-arg FFMPEG_IMAGE={{.FFMPEG_IMAGE}} \
          --build-arg VERSION={{.VERSION}} \
          --build-arg COMMIT={{.COMMIT}} \
          --build-arg BUILD_DATE={{.BUILD_DATE}} \
          --build-arg BRANCH={{.BRANCH}} \
          --build-arg TREE_STATE={{.TREE_STATE}} \
          -t ghcr.io/jmylchreest/tvarr:{{.TAG}} \
          -t ghcr.io/jmylchreest/tvarr:{{.VERSION_TAG}} \
          .

  container:build:ffmpegd:
    desc: Build tvarr-transcoder container image (distributed transcoding daemon)
    summary: |
      Builds the tvarr-transcoder container image (runs tvarr-ffmpegd binary).
      Requires the FFmpeg base image to exist (or will pull from GHCR).
      Auto-detects container runtime ({{.CONTAINER_RUNTIME}}) and platform ({{.LOCAL_ARCH}}).

      Options:
        - PLATFORM: Target platform (default: auto-detected {{.LOCAL_ARCH}})
        - TAG: Image tag (default: latest)
        - FFMPEG_IMAGE: FFmpeg base image (default: ghcr.io/jmylchreest/tvarr-ffmpeg:latest)
        - LOCAL: Use local images only, don't pull from registry (default: false)

      Note: If you've built the FFmpeg image locally with container:build:ffmpeg,
      use LOCAL=true to ensure the local image is used.
      Local builds also create a version-tagged image ({{.VERSION}}).
    vars:
      TAG: '{{.TAG | default "latest"}}'
      PLATFORM: '{{.PLATFORM | default .LOCAL_ARCH}}'
      FFMPEG_IMAGE: '{{.FFMPEG_IMAGE | default "ghcr.io/jmylchreest/tvarr-ffmpeg:latest"}}'
      LOCAL: '{{.LOCAL | default "false"}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} build \
          -f deployment/docker/Dockerfile.ffmpegd \
          --platform {{.PLATFORM}} \
          $([ "{{.LOCAL}}" = "true" ] && echo "--pull=never") \
          --build-arg FFMPEG_IMAGE={{.FFMPEG_IMAGE}} \
          --build-arg VERSION={{.VERSION}} \
          --build-arg COMMIT={{.COMMIT}} \
          --build-arg BUILD_DATE={{.BUILD_DATE}} \
          --build-arg BRANCH={{.BRANCH}} \
          --build-arg TREE_STATE={{.TREE_STATE}} \
          -t ghcr.io/jmylchreest/tvarr-transcoder:{{.TAG}} \
          -t ghcr.io/jmylchreest/tvarr-transcoder:{{.VERSION_TAG}} \
          .

  container:build:coordinator:
    desc: Build tvarr-coordinator container image (slim, no FFmpeg)
    summary: |
      Builds the lightweight tvarr-coordinator container image without FFmpeg.
      Use this for distributed-only deployments where all transcoding is done
      by remote ffmpegd workers.
      Auto-detects container runtime ({{.CONTAINER_RUNTIME}}) and platform ({{.LOCAL_ARCH}}).

      Options:
        - PLATFORM: Target platform (default: auto-detected {{.LOCAL_ARCH}})
        - TAG: Image tag (default: latest)

      Local builds also create a version-tagged image ({{.VERSION}}).

      For full tvarr with local FFmpeg transcoding, use:
        task container:build:tvarr
    vars:
      TAG: '{{.TAG | default "latest"}}'
      PLATFORM: '{{.PLATFORM | default .LOCAL_ARCH}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} build \
          -f deployment/docker/Dockerfile.coordinator \
          --platform {{.PLATFORM}} \
          --build-arg VERSION={{.VERSION}} \
          --build-arg COMMIT={{.COMMIT}} \
          --build-arg BUILD_DATE={{.BUILD_DATE}} \
          --build-arg BRANCH={{.BRANCH}} \
          --build-arg TREE_STATE={{.TREE_STATE}} \
          -t ghcr.io/jmylchreest/tvarr-coordinator:{{.TAG}} \
          -t ghcr.io/jmylchreest/tvarr-coordinator:{{.VERSION_TAG}} \
          .

  container:build:ffmpeg:
    desc: Build FFmpeg base container image
    summary: |
      Builds the FFmpeg base image with hardware acceleration support.
      This is typically done by CI, but can be built locally for testing.
      Versions are defined in the Dockerfile.
      Auto-detects container runtime ({{.CONTAINER_RUNTIME}}) and platform ({{.LOCAL_ARCH}}).

      The image is tagged with a hash of the Dockerfile ({{.FFMPEG_DOCKERFILE_HASH}})
      to match the CI workflow. If the image already exists locally or in GHCR,
      it won't be rebuilt unless FORCE=true is set.

      Options:
        - PLATFORM: Target platform (default: auto-detected {{.LOCAL_ARCH}})
        - TAG: Image tag override (default: hash-based {{.FFMPEG_DOCKERFILE_HASH}})
        - FORCE: Force rebuild even if image exists (default: false)
        - NO_CACHE: Build without using cache (default: false)

      Use container:build:tvarr after this to build tvarr using the local FFmpeg image.
    vars:
      TAG: '{{.TAG | default .FFMPEG_DOCKERFILE_HASH}}'
      PLATFORM: '{{.PLATFORM | default .LOCAL_ARCH}}'
      FORCE: '{{.FORCE | default "false"}}'
      NO_CACHE: '{{.NO_CACHE | default "false"}}'
    cmds:
      - |
        IMAGE="ghcr.io/jmylchreest/tvarr-ffmpeg:{{.TAG}}"

        # Check if image exists locally (skip check if NO_CACHE is set)
        if [[ "{{.FORCE}}" != "true" && "{{.NO_CACHE}}" != "true" ]] && {{.CONTAINER_RUNTIME}} image inspect "$IMAGE" >/dev/null 2>&1; then
          echo "Image $IMAGE already exists locally. Use FORCE=true to rebuild."
          exit 0
        fi

        echo "Building FFmpeg image: $IMAGE"
        {{.CONTAINER_RUNTIME}} build \
          -f deployment/docker/Dockerfile.ffmpeg \
          --target runtime \
          --platform {{.PLATFORM}} \
          $([ "{{.NO_CACHE}}" = "true" ] && echo "--no-cache") \
          -t "$IMAGE" \
          $([ "{{.TAG}}" = "{{.FFMPEG_DOCKERFILE_HASH}}" ] && echo "-t ghcr.io/jmylchreest/tvarr-ffmpeg:latest") \
          .

  container:shell:
    desc: Run tvarr container with interactive shell (for debugging)
    summary: |
      Starts the tvarr container with an interactive shell instead of the normal entrypoint.
      Useful for debugging, inspecting the container environment, or testing FFmpeg manually.
      Passes through DRI devices for hardware acceleration if available.
      Use NVIDIA=true to enable NVIDIA GPU passthrough (requires nvidia-container-toolkit).
    vars:
      TAG: '{{.TAG | default "latest"}}'
      NVIDIA: '{{.NVIDIA | default "false"}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} run --rm -it \
          -v tvarr-data:/data \
          $([ -d /dev/dri ] && echo "--device /dev/dri:/dev/dri") \
          $([ "{{.NVIDIA}}" = "true" ] && echo "--gpus all") \
          --entrypoint /bin/bash \
          ghcr.io/jmylchreest/tvarr:{{.TAG}}

  container:shell:ffmpeg:
    desc: Run FFmpeg base container with interactive shell (for debugging)
    summary: |
      Starts the FFmpeg base container with an interactive shell.
      Useful for testing FFmpeg/FFprobe commands, verifying hardware acceleration,
      or debugging codec issues without tvarr overhead.
      Passes through DRI devices for hardware acceleration if available.
      Use NVIDIA=true to enable NVIDIA GPU passthrough (requires nvidia-container-toolkit).

      Example commands once inside:
        ffmpeg -version               # Check FFmpeg build info
        ffmpeg -hwaccels              # List available hardware accelerators
        vainfo                        # Check VAAPI support (Intel/AMD)
        ffmpeg -encoders | grep nvenc # Check NVIDIA encoder support
        check-hwaccel                 # Run full hardware acceleration test
    vars:
      TAG: '{{.TAG | default "latest"}}'
      NVIDIA: '{{.NVIDIA | default "false"}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} run --rm -it \
          $([ -d /dev/dri ] && echo "--device /dev/dri:/dev/dri") \
          $([ "{{.NVIDIA}}" = "true" ] && echo "--gpus all") \
          --entrypoint /bin/bash \
          ghcr.io/jmylchreest/tvarr-ffmpeg:{{.TAG}}

  container:hwaccel:
    desc: Test hardware acceleration support in container
    summary: |
      Runs the hardware acceleration check script inside the FFmpeg container.
      Tests what HW encoders/decoders are actually working.

      Options:
        --quick, -q   Quick check (list available, skip encode tests)
        --json, -j    Output results as JSON
        --verbose, -v Show detailed FFmpeg output

      GPU Support:
        - Intel/AMD: Automatic via /dev/dri passthrough
        - NVIDIA: Use NVIDIA=true (requires nvidia-container-toolkit)

      Example:
        task container:hwaccel                  # Test Intel/AMD
        task container:hwaccel NVIDIA=true     # Test NVIDIA
        task container:hwaccel -- --quick       # Quick check only

      Inside container (interactive shell):
        check-hwaccel              # Run the test script
        check-hwaccel --quick      # Quick check
        check-hwaccel --json       # JSON output
    vars:
      TAG: '{{.TAG | default "latest"}}'
      NVIDIA: '{{.NVIDIA | default "false"}}'
      ARGS: '{{.CLI_ARGS}}'
    cmds:
      - |
        {{.CONTAINER_RUNTIME}} run --rm \
          $([ -d /dev/dri ] && echo "--device /dev/dri:/dev/dri") \
          $([ "{{.NVIDIA}}" = "true" ] && echo "--gpus all") \
          --entrypoint /usr/local/bin/check-hwaccel \
          ghcr.io/jmylchreest/tvarr-ffmpeg:{{.TAG}} {{.ARGS}}

  # ============================================
  # Docker Compose Tasks
  # ============================================

  compose:up:
    desc: Start tvarr coordinator + transcoder stack
    summary: |
      Starts the tvarr stack using docker-compose with coordinator and transcoder.

      The stack includes:
        - tvarr (coordinator with gRPC enabled)
        - tvarr-transcoder (ffmpegd daemon with GPU access)

      Variables:
        - NVIDIA: Set to "true" for NVIDIA GPU support (default: false, uses Intel/AMD)
        - DETACH: Set to "false" to run in foreground (default: true)

      Examples:
        task compose:up                    # Start with Intel/AMD GPU
        task compose:up NVIDIA=true        # Start with NVIDIA GPU
        task compose:up DETACH=false       # Run in foreground
    vars:
      NVIDIA: '{{.NVIDIA | default "false"}}'
      DETACH: '{{.DETACH | default "true"}}'
    cmds:
      - |
        cd deployment/docker
        if [ "{{.NVIDIA}}" = "true" ]; then
          {{.CONTAINER_RUNTIME}} compose -f docker-compose.yml -f docker-compose.nvidia.yml up \
            $([ "{{.DETACH}}" = "true" ] && echo "-d")
        else
          {{.CONTAINER_RUNTIME}} compose up $([ "{{.DETACH}}" = "true" ] && echo "-d")
        fi

  compose:down:
    desc: Stop tvarr coordinator + transcoder stack
    summary: |
      Stops and removes the tvarr stack containers.

      Variables:
        - VOLUMES: Set to "true" to also remove volumes (default: false)
    vars:
      VOLUMES: '{{.VOLUMES | default "false"}}'
    cmds:
      - |
        cd deployment/docker
        {{.CONTAINER_RUNTIME}} compose down $([ "{{.VOLUMES}}" = "true" ] && echo "-v")

  compose:logs:
    desc: View logs from tvarr stack
    summary: |
      Shows logs from the tvarr stack containers.
      Uses podman logs directly to properly aggregate logs from all containers.

      Variables:
        - FOLLOW: Set to "false" to not follow logs (default: true)
        - TAIL: Number of lines to show (default: 100, use "all" for full history)
        - SERVICE: Specific service to show logs for: tvarr, ffmpegd (default: all)

      Examples:
        task compose:logs                  # Follow all logs (last 100 lines)
        task compose:logs TAIL=all         # Follow all logs from start
        task compose:logs SERVICE=tvarr    # Only coordinator logs
        task compose:logs SERVICE=ffmpegd  # Only transcoder logs
        task compose:logs FOLLOW=false     # Show logs without following
    vars:
      FOLLOW: '{{.FOLLOW | default "true"}}'
      TAIL: '{{.TAIL | default "100"}}'
      SERVICE: '{{.SERVICE | default ""}}'
    cmds:
      - |
        TAIL_ARG=""
        if [ "{{.TAIL}}" != "all" ]; then
          TAIL_ARG="--tail={{.TAIL}}"
        fi
        FOLLOW_ARG=""
        if [ "{{.FOLLOW}}" = "true" ]; then
          FOLLOW_ARG="-f"
        fi

        # Get container names (use -a to include containers that aren't running yet)
        TVARR_CONTAINER=$({{.CONTAINER_RUNTIME}} ps -a --filter "name=docker_tvarr" --format "{{`{{.Names}}`}}" 2>/dev/null | head -1)
        FFMPEGD_CONTAINER=$({{.CONTAINER_RUNTIME}} ps -a --filter "name=docker_ffmpegd" --format "{{`{{.Names}}`}}" 2>/dev/null | head -1)

        if [ -n "{{.SERVICE}}" ]; then
          # Single service requested
          case "{{.SERVICE}}" in
            tvarr)
              [ -n "$TVARR_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $FOLLOW_ARG $TAIL_ARG "$TVARR_CONTAINER"
              ;;
            ffmpegd)
              [ -n "$FFMPEGD_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $FOLLOW_ARG $TAIL_ARG "$FFMPEGD_CONTAINER"
              ;;
            *)
              echo "Unknown service: {{.SERVICE}}. Use 'tvarr' or 'ffmpegd'"
              exit 1
              ;;
          esac
        else
          # All services - use tail to merge logs
          if [ "{{.FOLLOW}}" = "true" ]; then
            # Follow mode: run both in background and merge output
            (
              [ -n "$TVARR_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $FOLLOW_ARG $TAIL_ARG "$TVARR_CONTAINER" 2>&1 | sed -u 's/^/[tvarr] /' &
              [ -n "$FFMPEGD_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $FOLLOW_ARG $TAIL_ARG "$FFMPEGD_CONTAINER" 2>&1 | sed -u 's/^/[ffmpegd] /' &
              wait
            )
          else
            # Non-follow mode: show each sequentially
            echo "=== tvarr (coordinator) ==="
            [ -n "$TVARR_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $TAIL_ARG "$TVARR_CONTAINER"
            echo ""
            echo "=== ffmpegd (transcoder) ==="
            [ -n "$FFMPEGD_CONTAINER" ] && {{.CONTAINER_RUNTIME}} logs $TAIL_ARG "$FFMPEGD_CONTAINER"
          fi
        fi

  compose:ps:
    desc: Show status of tvarr stack containers
    cmds:
      - cd deployment/docker && {{.CONTAINER_RUNTIME}} compose ps

  compose:standalone:
    desc: Start tvarr all-in-one with local FFmpeg and gRPC enabled
    summary: |
      Starts a single tvarr container with everything included:
        - Local FFmpeg transcoding with GPU access
        - gRPC enabled (can add remote transcoders later)

      This is the simplest way to run tvarr. Remote transcoders can be
      added later by pointing them at this instance's gRPC port (9090).

      Variables:
        - NVIDIA: Set to "true" for NVIDIA GPU support (default: false, uses Intel/AMD)
        - DETACH: Set to "false" to run in foreground (default: true)

      Examples:
        task compose:standalone                # Start with Intel/AMD GPU
        task compose:standalone NVIDIA=true    # Start with NVIDIA GPU
        task compose:standalone DETACH=false   # Run in foreground
    vars:
      NVIDIA: '{{.NVIDIA | default "false"}}'
      DETACH: '{{.DETACH | default "true"}}'
    cmds:
      - |
        cd deployment/docker
        if [ "{{.NVIDIA}}" = "true" ]; then
          {{.CONTAINER_RUNTIME}} compose -f docker-compose.standalone.yml -f docker-compose.nvidia.yml up \
            $([ "{{.DETACH}}" = "true" ] && echo "-d")
        else
          {{.CONTAINER_RUNTIME}} compose -f docker-compose.standalone.yml up \
            $([ "{{.DETACH}}" = "true" ] && echo "-d")
        fi

  compose:standalone:down:
    desc: Stop tvarr standalone container
    vars:
      VOLUMES: '{{.VOLUMES | default "false"}}'
    cmds:
      - |
        cd deployment/docker
        {{.CONTAINER_RUNTIME}} compose -f docker-compose.standalone.yml down \
          $([ "{{.VOLUMES}}" = "true" ] && echo "-v")

  compose:standalone:logs:
    desc: View logs from tvarr standalone container
    vars:
      FOLLOW: '{{.FOLLOW | default "true"}}'
    cmds:
      - |
        cd deployment/docker
        {{.CONTAINER_RUNTIME}} compose -f docker-compose.standalone.yml logs \
          $([ "{{.FOLLOW}}" = "true" ] && echo "-f")

  # ============================================
  # UPX Compression Tasks
  # ============================================

  upx:compress:
    desc: Compress all release binaries with UPX (requires upx installed)
    preconditions:
      - sh: command -v upx
        msg: "UPX not found. Install via: apt install upx / brew install upx / pacman -S upx"
    cmds:
      - |
        echo "Compressing binaries with UPX..."
        for dir in {{.RELEASE_DIR}}/{{.BINARY_NAME}}_*; do
          if [ -d "$dir" ]; then
            for binary in "$dir"/{{.BINARY_NAME}} "$dir"/{{.BINARY_NAME}}.exe; do
              if [ -f "$binary" ]; then
                original_size=$(stat -c%s "$binary" 2>/dev/null || stat -f%z "$binary")
                upx --best --lzma "$binary" 2>/dev/null || upx --best "$binary" || echo "UPX failed for $binary"
                compressed_size=$(stat -c%s "$binary" 2>/dev/null || stat -f%z "$binary")
                ratio=$((100 - (compressed_size * 100 / original_size)))
                echo "  $binary: ${ratio}% reduction"
              fi
            done
          fi
        done

  upx:compress:file:
    desc: Compress a single file with UPX (FILE variable required)
    summary: |
      Compresses a single binary file with UPX.
      Used by the Dockerfile to compress the final tvarr binary.

      Usage:
        task upx:compress:file FILE=/path/to/binary
    requires:
      vars: [FILE]
    preconditions:
      - sh: command -v upx
        msg: "UPX not found. Install via: apt install upx / brew install upx / pacman -S upx"
      - sh: test -f "{{.FILE}}"
        msg: "File not found: {{.FILE}}"
    cmds:
      - |
        original_size=$(stat -c%s "{{.FILE}}" 2>/dev/null || stat -f%z "{{.FILE}}")
        echo "Compressing {{.FILE}} ($(numfmt --to=iec $original_size 2>/dev/null || echo "${original_size} bytes"))..."
        upx --best --lzma "{{.FILE}}" 2>/dev/null || upx --best "{{.FILE}}" || { echo "UPX compression failed"; exit 1; }
        compressed_size=$(stat -c%s "{{.FILE}}" 2>/dev/null || stat -f%z "{{.FILE}}")
        ratio=$((100 - (compressed_size * 100 / original_size)))
        echo "Compressed: $(numfmt --to=iec $compressed_size 2>/dev/null || echo "${compressed_size} bytes") (${ratio}% reduction)"

  # ============================================
  # Frontend Tasks
  # ============================================

  frontend:install:
    desc: Install frontend dependencies
    dir: "{{.FRONTEND_DIR}}"
    preconditions:
      - sh: command -v node
        msg: "Node.js not found. Install Node.js 24+ via your preferred method (fnm, nvm, volta, or direct install)"
      - sh: command -v pnpm
        msg: "pnpm not found. Install via npm install -g pnpm"
      - sh: 'node -e "process.exit(parseInt(process.version.slice(1)) >= 24 ? 0 : 1)"'
        msg: "Node.js 24+ required. Use fnm/nvm to switch, e.g. fnm use 24"
    cmds:
      - pnpm install
    sources:
      - package.json
      - pnpm-lock.yaml
    generates:
      - node_modules/.pnpm

  frontend:dev:
    desc: Run frontend in development mode
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - pnpm run dev

  frontend:build:
    desc: Build frontend for production
    dir: "{{.FRONTEND_DIR}}"
    deps: [frontend:install]
    env:
      VERSION: "{{.VERSION}}"
    cmds:
      - pnpm run build

  frontend:embed:
    desc: Build frontend and copy to assets for Go embedding
    dir: "{{.FRONTEND_DIR}}"
    deps: [frontend:install]
    env:
      VERSION: "{{.VERSION}}"
    cmds:
      - pnpm run build:embed
    sources:
      - src/**/*
      - public/**/*
      - package.json
      - next.config.js
      - tailwind.config.ts
    generates:
      - ../{{.ASSETS_DIR}}/**/*

  frontend:lint:
    desc: Lint frontend code
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - pnpm run lint

  frontend:typecheck:
    desc: Run TypeScript type checking
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - pnpm run type-check

  # ============================================
  # Release Tasks
  # ============================================

  release:archive:
    desc: Create release archives (tar.gz for unix, zip for windows)
    cmds:
      - |
        cd {{.RELEASE_DIR}}
        for dir in {{.BINARY_NAME}}_*_linux_* {{.BINARY_NAME}}_*_darwin_*; do
          if [ -d "$dir" ]; then
            tar -czvf "${dir}.tar.gz" "$dir"
          fi
        done
        for dir in {{.BINARY_NAME}}_*_windows_*; do
          if [ -d "$dir" ]; then
            zip -r "${dir}.zip" "$dir"
          fi
        done

  release:checksums:
    desc: Generate SHA256 checksums for release archives
    cmds:
      - |
        cd {{.RELEASE_DIR}}
        sha256sum *.tar.gz *.zip 2>/dev/null > checksums.txt || true
        cat checksums.txt

  release:local:
    desc: Build a full local release (all platforms + UPX + archives + checksums)
    cmds:
      - task: clean:release
      - task: frontend:embed
      - task: build:all
      - task: upx:compress
      - task: release:archive
      - task: release:checksums
      - echo "Release artifacts in {{.RELEASE_DIR}}/"

  # ============================================
  # Test Tasks
  # ============================================

  test:
    desc: Run all tests with coverage
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    cmds:
      - go test -v -coverprofile={{.COVERAGE_FILE}} ./...

  test:race:
    desc: Run tests with race detector (matches CI)
    env:
      CGO_ENABLED: "1"
    cmds:
      - go test -v -race -coverprofile={{.COVERAGE_FILE}} ./...

  test:short:
    desc: Run tests without verbose output (faster)
    cmds:
      - go test -short ./...

  test:coverage:
    desc: Generate and open coverage report
    cmds:
      - task: test
      - go tool cover -html={{.COVERAGE_FILE}} -o coverage.html
      - echo "Coverage report generated at coverage.html"

  bench:
    desc: Run benchmarks
    cmds:
      - go test -bench=. -benchmem ./...

  # ============================================
  # Lint & Verify Tasks
  # ============================================

  lint:
    desc: Run golangci-lint (v2)
    cmds:
      - |
        if ! command -v golangci-lint &> /dev/null; then
          echo "Installing golangci-lint v2..."
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
        fi
      - golangci-lint run ./...

  lint:fix:
    desc: Run golangci-lint with auto-fix
    cmds:
      - golangci-lint run --fix ./...

  lint:install:
    desc: Install or update golangci-lint v2
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    cmds:
      - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
      - golangci-lint version

  fmt:
    desc: Format code with gofmt
    cmds:
      - go fmt ./...

  vet:
    desc: Run go vet
    cmds:
      - go vet ./...

  verify:
    desc: Verify go.mod is tidy and code compiles (matches CI)
    cmds:
      - go mod tidy
      - git diff --exit-code go.mod go.sum || (echo "go.mod/go.sum not tidy" && exit 1)
      - go build ./...

  # ============================================
  # Security Tasks
  # ============================================

  security:
    desc: Run all security checks (matches CI security job)
    cmds:
      - task: security:gosec
      - task: security:vulncheck

  security:gosec:
    desc: Run gosec security scanner
    cmds:
      - |
        if ! command -v gosec &> /dev/null; then
          echo "Installing gosec..."
          go install github.com/securego/gosec/v2/cmd/gosec@latest
        fi
      - gosec -no-fail ./...

  security:vulncheck:
    desc: Run govulncheck for known vulnerabilities
    cmds:
      - |
        if ! command -v govulncheck &> /dev/null; then
          echo "Installing govulncheck..."
          go install golang.org/x/vuln/cmd/govulncheck@latest
        fi
      - govulncheck ./...

  security:install:
    desc: Install security scanning tools
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    cmds:
      - go install github.com/securego/gosec/v2/cmd/gosec@latest
      - go install golang.org/x/vuln/cmd/govulncheck@latest
      - echo "Security tools installed"

  # ============================================
  # CI Tasks (matches GitHub Actions ci.yml)
  # ============================================

  ci:
    desc: Run full CI pipeline (matches GitHub Actions)
    cmds:
      - task: lint
      - task: test:race
      - task: security
      - task: verify

  ci:quick:
    desc: Quick CI check (no race detector, no security)
    cmds:
      - task: lint
      - task: test:short
      - task: verify

  # ============================================
  # Run Tasks
  # ============================================

  run:
    desc: Build and run the application
    deps: [build]
    cmds:
      - ./{{.DEBUG_DIR}}/{{.BINARY_NAME}} serve

  run:dev:
    desc: Run Go backend + ffmpegd with hot reload
    summary: |
      Runs the Go backend server and ffmpegd daemon with hot reload using air.
      Both processes are rebuilt and restarted when code changes.
      JSON logs are formatted with hl, showing which process each line comes from.

      For full-stack development:
        Terminal 1: task run:dev       (Go backend on :8080 + ffmpegd on :9090)
        Terminal 2: task frontend:dev  (Next.js on :3000)

      The frontend dev server proxies API requests to the backend.
      For production builds, use 'task frontend:embed' to embed the UI.

      Options:
        - LOG_LEVEL: Log level for both processes (default: debug, supports: trace, debug, info, warn, error)

      Examples:
        task run:dev                    # Default debug level
        task run:dev LOG_LEVEL=trace    # Trace level (very verbose, includes heartbeats)

      Use 'task run:dev:json' for raw JSON log output.
    deps: [tools:hl, tools:air]
    interactive: true
    vars:
      LOG_LEVEL: '{{.LOG_LEVEL | default "debug"}}'
    cmds:
      - |
        trap 'kill 0; rm -f tmp/air.tvarr.toml tmp/air.ffmpegd.toml' EXIT
        mkdir -p tmp/tvarr tmp/ffmpegd
        rm -f tvarr-dev-*.log

        # Generate air configs with the specified log level
        sed 's/--log-level", "debug"/--log-level", "{{.LOG_LEVEL}}"/' air.tvarr.toml > tmp/air.tvarr.toml
        sed 's/--log-level", "debug"/--log-level", "{{.LOG_LEVEL}}"/' air.ffmpegd.toml > tmp/air.ffmpegd.toml

        touch tvarr-dev-tvarr.log tvarr-dev-ffmpegd.log
        stdbuf -oL air -c tmp/air.tvarr.toml >> tvarr-dev-tvarr.log 2>&1 &
        stdbuf -oL air -c tmp/air.ffmpegd.toml >> tvarr-dev-ffmpegd.log 2>&1 &
        hl -F --tail 0 --input-info full tvarr-dev-*.log

  run:dev:json:
    desc: Run Go backend + ffmpegd with hot reload (raw JSON logs)
    summary: |
      Same as run:dev but outputs raw JSON logs without formatting.
      Useful for piping to other tools or debugging log parsing issues.

      Options:
        - LOG_LEVEL: Log level for both processes (default: debug, supports: trace, debug, info, warn, error)
    deps: [tools:air]
    interactive: true
    vars:
      LOG_LEVEL: '{{.LOG_LEVEL | default "debug"}}'
    cmds:
      - |
        trap 'kill 0; rm -f tmp/air.tvarr.toml tmp/air.ffmpegd.toml' EXIT
        mkdir -p tmp/tvarr tmp/ffmpegd

        # Generate air configs with the specified log level
        sed 's/--log-level", "debug"/--log-level", "{{.LOG_LEVEL}}"/' air.tvarr.toml > tmp/air.tvarr.toml
        sed 's/--log-level", "debug"/--log-level", "{{.LOG_LEVEL}}"/' air.ffmpegd.toml > tmp/air.ffmpegd.toml

        air -c tmp/air.tvarr.toml &
        air -c tmp/air.ffmpegd.toml &
        wait

  run:prod:
    desc: Build with embedded frontend and run (production-like)
    cmds:
      - task: frontend:embed
      - task: build
      - ./{{.DEBUG_DIR}}/{{.BINARY_NAME}} serve

  # ============================================
  # Tool Installation Tasks
  # ============================================

  tools:hl:
    desc: Install hl (pamburus/hl) for formatted JSON log output
    status:
      - command -v hl
      - hl --version 2>&1 | grep -q pamburus
    cmds:
      - |
        set -e

        # Detect OS
        OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
        case "$OS" in
          linux)  OS="linux" ;;
          darwin) OS="macos" ;;
          *)      echo "Unsupported OS: $OS"; exit 1 ;;
        esac

        # Detect architecture
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64|amd64)  ARCH="x86_64" ;;
          aarch64|arm64) ARCH="arm64" ;;
          *)             echo "Unsupported architecture: $ARCH"; exit 1 ;;
        esac

        # Build download URL (use musl for Linux for better portability)
        if [ "$OS" = "linux" ]; then
          FILENAME="hl-${OS}-${ARCH}-musl.tar.gz"
        else
          FILENAME="hl-${OS}-${ARCH}.tar.gz"
        fi

        # Get latest release URL
        RELEASE_URL="https://github.com/pamburus/hl/releases/latest/download/${FILENAME}"

        # Create temp directory
        TMPDIR="$(mktemp -d)"
        trap "rm -rf $TMPDIR" EXIT

        echo "Downloading hl from ${RELEASE_URL}..."
        curl -fsSL "$RELEASE_URL" -o "$TMPDIR/hl.tar.gz"

        # Extract
        tar -xzf "$TMPDIR/hl.tar.gz" -C "$TMPDIR"

        # Install to ~/.local/bin (create if needed)
        INSTALL_DIR="${HOME}/.local/bin"
        mkdir -p "$INSTALL_DIR"
        mv "$TMPDIR/hl" "$INSTALL_DIR/hl"
        chmod +x "$INSTALL_DIR/hl"

        echo "hl installed to ${INSTALL_DIR}/hl"

        # Check if ~/.local/bin is in PATH
        if ! echo "$PATH" | grep -q "${HOME}/.local/bin"; then
          echo ""
          echo "NOTE: Add ~/.local/bin to your PATH:"
          echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
        fi

  tools:hl:cargo:
    desc: Install hl via cargo (requires Rust)
    preconditions:
      - sh: command -v cargo
        msg: |
          cargo (Rust) not found. Install Rust via:
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    status:
      - command -v hl
      - hl --version 2>&1 | grep -q pamburus
    cmds:
      - cargo install --locked --git https://github.com/pamburus/hl.git

  tools:air:
    desc: Install air for hot reload development
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
            brew install go (macOS)
            sudo apt install golang-go (Debian/Ubuntu)
    status:
      - command -v air
    cmds:
      - go install github.com/air-verse/air@latest

  # ============================================
  # Dependency Tasks
  # ============================================

  deps:
    desc: Download and tidy dependencies
    cmds:
      - go mod download
      - go mod tidy

  deps:update:
    desc: Update Go dependencies within compatible versions
    cmds:
      - go get -u=patch ./...
      - go mod tidy

  deps:upgrade:
    desc: Upgrade Go dependencies to latest versions (may include breaking changes)
    cmds:
      # Filter symlink warnings from pnpm's node_modules structure
      - |
        go get -u ./... 2>&1 | grep -v "warning: ignoring symlink" || true
      - |
        go mod tidy 2>&1 | grep -v "warning: ignoring symlink" || true

  deps:update:all:
    desc: Update all dependencies within compatible versions (safe)
    cmds:
      - task: deps:update
      - task: frontend:deps:update
      - task: docs:deps:update
      - task: deps:check:external

  deps:upgrade:all:
    desc: Upgrade all dependencies to latest versions (Go + frontend + docs + external)
    cmds:
      - task: deps:upgrade
      - task: frontend:deps:upgrade
      - task: docs:deps:upgrade
      - task: deps:upgrade:external

  deps:check:external:
    desc: Check external dependencies (FFmpeg, gosu) for updates
    cmds:
      - ./scripts/update-dependencies.sh --check

  deps:upgrade:external:
    desc: Upgrade external dependencies (FFmpeg, gosu) to latest versions
    cmds:
      - ./scripts/update-dependencies.sh --update

  # Frontend dependency tasks
  frontend:deps:update:
    desc: Update frontend dependencies within semver ranges (safe)
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - pnpm update

  frontend:deps:upgrade:
    desc: Upgrade frontend dependencies to latest versions (may include breaking changes)
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - npx npm-check-updates -u
      - pnpm install

  # Docs dependency tasks (Docusaurus documentation site)
  docs:deps:update:
    desc: Update docs dependencies within semver ranges (safe)
    dir: docs
    cmds:
      - npm update

  docs:deps:upgrade:
    desc: Upgrade docs dependencies to latest versions (may include breaking changes)
    dir: docs
    cmds:
      - npx npm-check-updates -u
      - npm install

  # ============================================
  # Code Generation Tasks
  # ============================================

  generate:
    desc: Run all code generation (go generate + protobuf)
    cmds:
      - task: generate:proto
      - go generate ./...

  generate:proto:
    desc: Generate Go code from protobuf definitions
    summary: |
      Generates Go code from .proto files in pkg/ffmpegd/proto/.
      Requires protoc and protoc-gen-go/protoc-gen-go-grpc installed.

      Install protoc plugins:
        go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
        go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
    preconditions:
      - sh: command -v protoc
        msg: |
          protoc not found. Install via:
            apt install protobuf-compiler (Debian/Ubuntu)
            brew install protobuf (macOS)
            pacman -S protobuf (Arch)
      - sh: command -v protoc-gen-go
        msg: |
          protoc-gen-go not found. Install via:
            go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
      - sh: command -v protoc-gen-go-grpc
        msg: |
          protoc-gen-go-grpc not found. Install via:
            go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
    cmds:
      - |
        echo "Generating Go code from protobuf definitions..."
        protoc \
          --go_out=. \
          --go-grpc_out=. \
          --go_opt=paths=source_relative \
          --go-grpc_opt=paths=source_relative \
          pkg/ffmpegd/proto/ffmpegd.proto
        echo "Generated: pkg/ffmpegd/proto/*.pb.go"

  generate:proto:install:
    desc: Install protobuf code generation tools
    preconditions:
      - sh: command -v go
        msg: |
          Go not found. Install Go 1.23+ via:
            https://go.dev/dl/
    cmds:
      - go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
      - go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
      - echo "Protobuf Go plugins installed"

  # ============================================
  # Clean Tasks
  # ============================================

  clean:
    desc: Clean debug build artifacts
    cmds:
      - rm -rf {{.DEBUG_DIR}}
      - rm -f {{.COVERAGE_FILE}} coverage.html
      - rm -f cpu.prof mem.prof

  clean:release:
    desc: Clean release artifacts
    cmds:
      - rm -rf {{.RELEASE_DIR}}

  clean:dist:
    desc: Clean all distribution artifacts (debug + release)
    cmds:
      - rm -rf {{.DIST_DIR}}

  clean:frontend:
    desc: Clean frontend build artifacts
    cmds:
      - rm -rf {{.FRONTEND_DIR}}/.next
      - rm -rf {{.FRONTEND_DIR}}/out
      - rm -rf {{.ASSETS_DIR}}/*
      - touch {{.ASSETS_DIR}}/.gitkeep

  clean:frontend:all:
    desc: Clean frontend build artifacts AND node_modules
    cmds:
      - task: clean:frontend
      - rm -rf {{.FRONTEND_DIR}}/node_modules

  clean:all:
    desc: Clean everything including caches
    cmds:
      - task: clean
      - task: clean:dist
      - task: clean:frontend
      - go clean -cache -testcache

  clean:deep:
    desc: Deep clean - removes ALL transient/regeneratable artifacts
    summary: |
      Performs a comprehensive cleanup of all transient files that can be regenerated.
      This includes everything from clean:all plus:
        - Go test binaries (*.test) in project root
        - Taskfile cache (.task/)
        - Frontend node_modules (requires pnpm install to restore)

      Safe to run anytime - all removed files are regenerated by builds/tests.
      Estimated space savings: 3-4GB depending on cache sizes.

      Use clean:deep:full to also clear Go module cache (requires re-download).
    cmds:
      - task: clean
      - task: clean:dist
      - task: clean:frontend:all
      - rm -f *.test
      - rm -rf .task/
      - go clean -cache -testcache
      - echo "Deep clean complete. Run 'task clean:deep:full' to also clear Go module cache."

  clean:deep:full:
    desc: Full deep clean including Go module cache (requires re-download)
    cmds:
      - task: clean:deep
      - go clean -modcache
      - echo "Full deep clean complete. Go modules will be re-downloaded on next build."

  # ============================================
  # Version Info
  # ============================================

  info:
    desc: Show version information that would be built
    cmds:
      - 'echo "Version:    {{.VERSION}}"'
      - 'echo "Commit:     {{.COMMIT}}"'
      - 'echo "Branch:     {{.BRANCH}}"'
      - 'echo "Tree State: {{.TREE_STATE}}"'
      - 'echo "Build Date: {{.BUILD_DATE}}"'

  # ============================================
  # Version Sync Tasks
  # ============================================

  version:
    desc: Show current version information
    cmds:
      - |
        PKG_JSON="{{.FRONTEND_DIR}}/package.json"
        PKG_VERSION=$(grep -o '"version": "[^"]*"' "$PKG_JSON" | cut -d'"' -f4)
        GIT_VERSION="{{.VERSION}}"

        echo "=== Version Info ==="
        echo ""
        echo "Git-derived version: ${GIT_VERSION}"
        echo "Frontend package.json: ${PKG_VERSION}"
        echo ""
        if [ "$PKG_VERSION" = "$GIT_VERSION" ]; then
          echo "Status: IN SYNC"
        else
          echo "Status: OUT OF SYNC"
          echo ""
          echo "To sync: task version:sync"
        fi

  version:sync:
    desc: Sync frontend package.json version with git version
    summary: |
      Updates frontend/package.json to match the current git-derived version.
      Use FORCE=true to allow setting a lower version than current.

      Examples:
        task version:sync                    # Sync to current git version
        task version:sync VERSION=1.2.3     # Set specific version
        task version:sync VERSION=0.1.0 FORCE=true  # Force lower version
    cmds:
      - |
        TARGET="{{.VERSION}}"
        FORCE="{{.FORCE}}"
        PKG_JSON="{{.FRONTEND_DIR}}/package.json"

        # Get current package.json version
        CURRENT=$(grep -o '"version": "[^"]*"' "$PKG_JSON" | cut -d'"' -f4)

        echo "Current package.json version: ${CURRENT}"
        echo "Target version:               ${TARGET}"

        # Skip if already at target
        if [ "$CURRENT" = "$TARGET" ]; then
          echo "Already at target version. Nothing to do."
          exit 0
        fi

        # Version comparison function (returns 0 if $1 >= $2)
        version_gte() {
          [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" = "$2" ]
        }

        # Check if downgrading without force
        if [ "$FORCE" != "true" ] && version_gte "$CURRENT" "$TARGET" && [ "$CURRENT" != "$TARGET" ]; then
          echo ""
          echo "Error: Target version ($TARGET) is lower than current ($CURRENT)"
          echo "Use FORCE=true to override: task version:sync VERSION=$TARGET FORCE=true"
          exit 1
        fi

        # Update package.json using sed (portable)
        sed -i "s/\"version\": \"${CURRENT}\"/\"version\": \"${TARGET}\"/" "$PKG_JSON"

        echo ""
        echo "Updated $PKG_JSON to version ${TARGET}"

  version:check:
    desc: Check if frontend version matches git version
    cmds:
      - |
        PKG_JSON="{{.FRONTEND_DIR}}/package.json"
        CURRENT=$(grep -o '"version": "[^"]*"' "$PKG_JSON" | cut -d'"' -f4)
        GIT_VERSION="{{.VERSION}}"

        echo "Frontend package.json: ${CURRENT}"
        echo "Git-derived version:   ${GIT_VERSION}"

        if [ "$CURRENT" = "$GIT_VERSION" ]; then
          echo ""
          echo "Versions are in sync."
        else
          echo ""
          echo "Warning: Versions are out of sync!"
          echo "Run 'task version:sync' to update package.json"
          exit 1
        fi

  # ============================================
  # Version Bump & Release Tasks
  # ============================================

  bump:major:
    desc: Show next major version (X.0.0)
    cmds:
      - task: _bump
        vars:
          BUMP_TYPE: major

  bump:minor:
    desc: Show next minor version (X.Y.0)
    cmds:
      - task: _bump
        vars:
          BUMP_TYPE: minor

  bump:patch:
    desc: Show next patch version (X.Y.Z)
    cmds:
      - task: _bump
        vars:
          BUMP_TYPE: patch

  bump:
    desc: Show next patch version (alias for bump:patch)
    cmds:
      - task: bump:patch

  _bump:
    internal: true
    cmds:
      - |
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        CURRENT_VERSION="${LAST_TAG#v}"
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        MAJOR=${MAJOR:-0}; MINOR=${MINOR:-0}; PATCH=${PATCH:-0}

        case "{{.BUMP_TYPE}}" in
          major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
          minor) NEW_VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
          patch|*) NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
        esac

        echo "Current: ${CURRENT_VERSION} -> Next: ${NEW_VERSION}"
        echo "To release: task release VERSION=${NEW_VERSION}"

  release:
    desc: Create and push a release tag (VERSION required)
    requires:
      vars: [VERSION]
    cmds:
      - |
        VERSION="{{.VERSION}}"
        TAG="v${VERSION}"
        PKG_JSON="{{.FRONTEND_DIR}}/package.json"

        # Validate version format
        if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "Error: VERSION must be in format X.Y.Z (e.g., 1.2.3)"
          exit 1
        fi

        # Check if tag already exists
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "Error: Tag $TAG already exists"
          exit 1
        fi

        # Sync frontend package.json version if needed
        CURRENT_PKG_VERSION=$(grep -o '"version": "[^"]*"' "$PKG_JSON" | cut -d'"' -f4)
        if [ "$CURRENT_PKG_VERSION" != "$VERSION" ]; then
          sed -i "s/\"version\": \"${CURRENT_PKG_VERSION}\"/\"version\": \"${VERSION}\"/" "$PKG_JSON"
          git add "$PKG_JSON"
          git commit -m "chore: bump version to ${VERSION}"
        fi

        # Get previous tag for changelog
        PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        # Create annotated tag with changelog
        CHANGELOG=$(
          echo "Release ${VERSION}"
          echo ""
          if [ -n "$PREV_TAG" ]; then
            echo "Changes since ${PREV_TAG}:"
            git log "${PREV_TAG}..HEAD" --pretty=format:"- %s" --no-merges
          else
            echo "Initial release"
          fi
        )

        git tag -a "${TAG}" -m "${CHANGELOG}"
        git push origin "${TAG}"
        echo "Released ${TAG}"

  # ============================================
  # E2E Testing Tasks
  # ============================================

  e2e:build:
    desc: Build the E2E test runner and tvarr binaries
    deps: [build]
    cmds:
      - mkdir -p {{.DEBUG_DIR}}
      - go build -o {{.DEBUG_DIR}}/e2e-runner ./cmd/e2e-runner

  e2e:
    desc: Run full E2E test with in-memory database (no external dependencies)
    summary: |
      Runs E2E tests with the e2e-runner managing its own tvarr server.
      Uses a random high port (never 8080) to avoid conflicts with local dev instances.
      Uses :memory: SQLite DSN and unique temp directory for storage.
      Cleanup happens automatically via the e2e-runner.
      This is the recommended way to run E2E tests in CI.

      By default, generates random test data (50 channels, 5000 programs) using
      fictional broadcaster names. Test data is written to temp files and served
      via file:// URLs.

      Options via environment variables:
        - CHANNEL_COUNT: Number of channels to generate (default: 50)
        - PROGRAM_COUNT: Total number of programs to generate (default: 5000)
        - RANDOM_SEED: Seed for reproducible test data (default: time-based)
        - REQUIRED_CHANNELS: Fail if generated channels don't match (default: 0, disabled)
        - REQUIRED_PROGRAMS: Fail if generated programs don't match (default: 0, disabled)
        - CACHE_CHANNEL_LOGOS: Enable channel logo caching (default: true)
        - CACHE_PROGRAM_LOGOS: Enable program logo caching (default: true)
        - NO_RANDOM_TESTDATA: Set to disable random test data and use external URLs
        - M3U_URL: Custom M3U source URL (only when NO_RANDOM_TESTDATA is set)
        - EPG_URL: Custom EPG source URL (only when NO_RANDOM_TESTDATA is set)
    deps: [e2e:build]
    cmds:
      - |
        # Run E2E tests with managed server mode (random high port)
        # Uses random test data by default (fictional channels/programs)
        ./{{.DEBUG_DIR}}/e2e-runner \
          -binary ./{{.DEBUG_DIR}}/{{.BINARY_NAME}} \
          {{if .NO_RANDOM_TESTDATA}}-random-testdata=false{{end}} \
          {{if .CHANNEL_COUNT}}-channel-count {{.CHANNEL_COUNT}}{{end}} \
          {{if .PROGRAM_COUNT}}-program-count {{.PROGRAM_COUNT}}{{end}} \
          {{if .RANDOM_SEED}}-random-seed {{.RANDOM_SEED}}{{end}} \
          {{if .REQUIRED_CHANNELS}}-required-channels {{.REQUIRED_CHANNELS}}{{end}} \
          {{if .REQUIRED_PROGRAMS}}-required-programs {{.REQUIRED_PROGRAMS}}{{end}} \
          {{if .M3U_URL}}-m3u-url "{{.M3U_URL}}"{{end}} \
          {{if .EPG_URL}}-epg-url "{{.EPG_URL}}"{{end}} \
          {{if .CACHE_CHANNEL_LOGOS}}-cache-channel-logos{{end}} \
          {{if .CACHE_PROGRAM_LOGOS}}-cache-program-logos{{end}} \
          -test-proxy-modes

  help:
    desc: Show all available tasks
    cmds:
      - task --list-all
